<html lang="en">
    <head>
        <title>Fallout 76 Drop Chances</title>
        <style>
            * {
                font-family: sans-serif;
                font-size: 20px;
            }
            td {
                padding: 2px;
            }
            
            table.infoTable {
               border: 1px solid black;
               border-collapse: collapse;
            }
            table.infoTable td {
               border: 1px solid black;
            }

            .picker {
                border:1px dotted green; 
                text-decoration: none;
                font-weight: bold; 
                background-color: #E0FFFF; 
                padding-left: 3px; 
                padding-right: 3px;
                box-shadow: 2px 2px #888888;
            }
            .pickerOn {
                border:1px dotted black; 
                text-decoration: none;
                font-weight: bold; 
                background-color: #A0FFA0; 
                padding-left: 3px; 
                padding-right: 3px;
                box-shadow: 2px 2px #888888;
            }

            .monospaced {
                font-family: monospace;
            }
        </style>
        <meta name="keywords" content="Fallout,Fallout 76,RNG,Random,Chances,Leveled,Leveled List,LVLI,Datamine">
    </head>
    <body>
        <center>
            <span style="font-size: 36px; font-weight: bold;">Fallout 76 Drop Chances (0.4.0)</span><br/>
            <a href='leveledlist' target='_blank'>How does it work?</a>
            <br/>
            <br/>
            Select version:
            <select id='versionselect'>
                <option value='P45'>Update 45: 18th July, 2023</option>
                <option value='P46'>Update 46: 22nd August, 2023</option>
                <option value='P47'>Update 47: 10th October, 2023</option>
                <option value='P48'>Update 48: 10th October, 2023</option>
                <option value='P49'>Update 49: 30th January, 2024</option>
                <option value='P50' selected>Update 50: 26th March, 2024</option>
                <option value='P51' selected>Update 51: 30th April, 2024 (latest)</option>
            </select>
            &nbsp;&nbsp;
            <button id='loadversion'>Load</button>
            &nbsp;&nbsp;&nbsp;&nbsp;
            <button id='resetPage'>Reset</button>
            <!-- &nbsp; (Note that the site downloads up to 3MB of data for the selected version!) -->
            <hr>
            <table>
                <tr>
                    <td id='listsearchtip'>
                    </td>
                    <td>
                        <input id='listsearchterm' name='listsearchterm' type='text' style='width: 300px;' value='' autocomplete="on">&nbsp;<button id='listsearchbtn'>Find</button>
                    </td>
                    <td style='width: 30px;'></td>
                    <td id='itemsearchtip'>

                    </td>
                    <td>
                        <input id='itemsearchterm' name='itemsearchterm' type='text' style='width: 300px;' value='' autocomplete="on">&nbsp;<button id='itemsearchbtn'>Find</button>
                    </td>
                    <td style='padding-left: 30px'>
                        <button id='clearResults'>Clear results</button>
                    </td>
                    <td>
                        <input type='checkbox' id="FindSpecial" checked><label for="FindSpecial">Special search options</label>
                    </td>
                </tr>
                <tr id='FindSpecialRow'>
                    <td colspan='7' style='text-align: center;'>
                        <button id='SpecialAllMax0' title='Lists with Flags=all and Max=0'>All/Max=0</button>&nbsp;
                        <button id='SpecialAllMax1' title='Lists with Flags=all and Max=1'>All/Max=1</button>&nbsp;
                        <button id='SpecialAllMax2' title='Lists with Flags=all and Max&gt;1'>All/Max&gt;1</button>&nbsp;
                        <button id='SpecialAllMaxGlobal' title='Lists with flags=all and Max=Global value'>All/Max=Global</button>&nbsp;
                        <button id='SpecialFirst' title='Lists with flags=first-match-all-conditions'>First</button>&nbsp;
                        <button id='SpecialFirstSub' title='Lists with flags=first-match-all-conditions and having sublists'>First+Sublist</button>&nbsp;
                        <button id='SpecialForEach' title='Lists with flags=for-each'>ForEach</button>&nbsp;
                        <button id='SpecialPickRandom' title='Lists with flags=not all and not for-each'>PickRandom</button>&nbsp;
                        <button id='SpecialListChanceNone' title='Lists which have Chance None nonzero'>ListChanceNone &gt; 0</button>&nbsp;
                        <button id='SpecialGetRandomPercent' title='Lists which have conditions with GetRandomPercent'>GetRandomPercent</button>&nbsp;
                        <button id='SpecialBugged1' title='Lists which are defined Flags=all and Max=1, but they only ever return their first entries'>All/Max=1 always first</button>&nbsp;
                        <button id='SpecialBugged2' title='Lists which are defined Flags=0 and having conditions on entries'>Random/Conditioned</button>&nbsp;
                        <button id='SpecialSelfTest' title='Lists testing the calculations'>Self-test lists</button>&nbsp;
                    </td>
                </tr>
                <tr>
                    <td colspan='7' style='text-align: center;'>
                        <input type='checkbox' id='IncludeATX' checked><label for='IncludeATX'>Include Atom Shop</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='IncludeCut'><label for='IncludeCut'>Include cut content</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='IncludeDebug'><label for='IncludeDebug'>Include debug content</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='SortByEditorID' checked><label for='SortByEditorID'>Sort by EditorID</label>
                    </td>
                </tr>
            </table>
            <hr>
            <table id='searchresults'>

            </table>
            <hr>
            <span id='tablelinks'>
            </span>
            <br/><br/>
            <input type='checkbox' id='Coalesce' checked><label for='Coalesce'>Coalesce duplicate entries</label>
            <input type='checkbox' id='ShowFailedConditions' checked><label for='ShowFailedConditions'>Show entries with failed conditions</label>
            <br/><br/>
            <span id='settingstoggle' style='border: 1px solid black; font-family: monospace; cursor: pointer;'>&nbsp;-&nbsp;</span>&nbsp;<b>List settings:</b>
            <table id='settings' style='border-collapse: collapse; margin-top: 5px;'>
                <tr>

                    <td style='border: 1px solid gray; vertical-align: top;'>
                        <div id="settingsCheckboxes" style='overflow-y: scroll; height: 150px;'>
                        </div>
                    </td>
                    <td style='border: 1px solid gray; vertical-align: top;'>
                        <div id="settingsComboboxes" style='overflow-y: scroll; height: 150px;'>
                        </div>
                    </td>
                    <td style='border: 1px solid gray; vertical-align: top;'>
                        <div id="settingsGlobals" style='overflow-y: scroll; height: 150px;'>
                        </div>
                    </td>
                </tr>
            </table>
            
            <table id='listtable' style='margin-top: 15px;'>
            </table>
            <br>
            <br>
            <input id='simulate' type='checkbox'><label for='simulate'>Generate drops via simulation :</label>
            &nbsp;&nbsp;&nbsp;<input type="number" id='simulateRolls' value="100000" min="1" /> (rolls)
            &nbsp;&nbsp;&nbsp;<button id='rollagain'>Roll again!</button>
            <br>

            <br>
            <span style="font-size: 24px; font-weight: bold;">Item probabilities</span><br/>
            <table id='itemtable' style='margin-top: 15px;'>
            </table>
        </center>
        <script>
            // property key is the FormID, property value is the Group string (4chars) concatenated with the EditorID
            var edids = {};
            // property key is the FormID, property value is the global float
            var globals = {};
            // property key is the FormID, property value is the leveled list object
            var leveledLists = {};
            // property key is the FormID, property value is an array of objects with the form { "x": 0, "y" : 0 }
            var curves = {};

            var downloadDone = 0;

            // the currently shown chain of formids
            var currentFormIDs = [];

            // up to how many list items to consider for the formula evaluations
            var formulaLimit = 20;
            // how many runs to do for the monte-carlo simulation
            var monteCarloCount = 1 << 18;

            // if a number > 0 but less than epsilon, it is treated as zero.
            var epsilon = 0.000001;

            function allDownloaded() {
                document.getElementById("loadversion").disabled = false;

                /*
                console.log(Object.keys(edids).length);
                console.log(Object.keys(globals).length);
                console.log(Object.keys(leveledLists).length);
                console.log(Object.keys(curves).length);
                */

                createTestLists();

                // find cross references
                for (var listID in leveledLists) {

                    var lvli = leveledLists[listID];

                    if (lvli.Entries !== undefined) {
                        for (var entry of lvli.Entries) {

                            var refList = leveledLists[entry.Object];

                            if (refList !== undefined) {
                                if (refList.Parents === undefined) {
                                    refList.Parents = [];
                                }
                                if (!refList.Parents.includes(listID)) {
                                    refList.Parents.push(listID);
                                }
                            }
                        }
                    }
                }

                // gatherFunctionNames();
                // findMixedConditions();

                var q = location.search;
                if (q.includes("formids=")) {
                    var idx = q.indexOf("formids=");
                    var jdx = q.indexOf("&", idx + 8);
                    if (jdx < 0) {
                        jdx = q.length;
                    }
                    var ids = q.substring(idx + 8, jdx).split("-");
                    showChain(ids);
                }
                if (q.includes("itemsearchterm=")) {
                    var idx = q.indexOf("itemsearchterm=");
                    var jdx = q.indexOf("&", idx + 15);
                    if (jdx < 0) {
                        jdx = q.length;
                    }
                    document.getElementById("itemsearchterm").value = q.substring(idx + 15, jdx);
                    searchItems();                    
                }
            }

            function createTestLists() {
                // An All/Max=1 list with two entries
                leveledLists["A0000001"] = {
                    LVLF: 4,
                    LVMV: 1,
                    Entries: [
                        {
                            Object: "A0000002",
                            LVIV: 6,
                            LVOV: 50
                        },
                        {
                            Object: "AA000001"
                        }
                    ]
                };
                leveledLists["A0000002"] = {
                    LVLF: 3,
                    Entries: [
                        {
                            Object: "A0000003"
                        }
                    ]
                };

                leveledLists["A0000003"] = {
                    LVLF: 4,
                    LVMV: 1,
                    Entries: [
                        {
                            Object: "AA000002",
                            LVOV: 20
                        },
                        {
                            Object: "AA000003",
                            LVOV: 0
                        }
                    ]
                }

                edids["A0000001"] = "LVLITestList_A1 All/Max=1 list with two entries";
                edids["A0000002"] = "LVLITestList_A2 forEach list with one entry";
                edids["A0000003"] = "LVLITestList_A3 All/Max=1 list with two entries";

                edids["AA000001"] = "MISCTest_Entry_1 Test Entry 1";
                edids["AA000002"] = "MISCTest_Entry_2 Test Entry 2";
                edids["AA000003"] = "MISCTest_Entry_3 Test Entry 3";
                edids["AA000004"] = "MISCTest_Entry_4 Test Entry 4";
                edids["AA000005"] = "MISCTest_Entry_5 Test Entry 5";

                // Create test list for foreach+condition entries

                leveledLists["A0000004"] = {
                    LVLF: 3,
                    Entries: [
                        {
                            Object: "AA000001"
                        },
                        {
                            Object: "AA000002",
                            Conditions: [
                                {
                                    "Operator": 0,
                                    "Value": 1.0,
                                    "Function": 4955,
                                    "FunctionName": "HasEntitlement",
                                    "Param1Ref": "005ACF95",
                                    "Param1Value": 8.339661E-39,
                                    "Param2Ref": "00000000",
                                    "Param2Value": 0.0,
                                    "RunOn": "Subject"
                                }
                            ]
                        },
                        {
                            Object: "AA000003"
                        }
                    ]
                };
                leveledLists["A0000005"] = {
                    LVLF: 0,
                    Entries: [
                        {
                            Object: "AA000001"
                        },
                        {
                            Object: "AA000002",
                            Conditions: [
                                {
                                    "Operator": 0,
                                    "Value": 1.0,
                                    "Function": 4955,
                                    "FunctionName": "HasEntitlement",
                                    "Param1Ref": "005ACF95",
                                    "Param1Value": 8.339661E-39,
                                    "Param2Ref": "00000000",
                                    "Param2Value": 0.0,
                                    "RunOn": "Subject"
                                }
                            ]
                        },
                        {
                            Object: "AA000003"
                        }
                    ]
                }
                edids["A0000004"] = "LVLITestList_A4 for-each + condition entries";
                edids["A0000005"] = "LVLITestList_A4 one-random + condition entries";
            }

            function findMixedConditions() {
                var formIDs = new Map();

                for (var listID in leveledLists) {

                    var lvli = leveledLists[listID];

                    if (lvli.Conditions !== undefined) {
                        var logic = 0;
                        for (var cond of lvli.Conditions) {
                            if ((cond.Operator & 1) == 0) {
                                logic |= 1;
                            } else {
                                logic |= 2;
                            }
                        }

                        if (logic == 3) {
                            formIDs.set(listID, listID);
                        }
                    }
                    if (lvli.Entries !== undefined) {
                        for (var entry of lvli.Entries) {
                            if (entry.Conditions !== undefined) {
                                var logic = 0;
                                for (var cond of entry.Conditions) {
                                    if ((cond.Operator & 1) == 0) {
                                        logic |= 1;
                                    } else {
                                        logic |= 2;
                                    }
                                }
                                if (logic == 3) {
                                    formIDs.set(listID, listID);
                                }
                            }
                        }
                    }
                }

                for (var fn of formIDs.values()) {
                    console.log(fn);
                }
            }

            function gatherFunctionNames() {
                // TEMPORARY: dump unique "FunctionName"s
                /*
                var functionNames = new Map();
                for (var listID in leveledLists) {

                    var lvli = leveledLists[listID];

                    if (lvli.Conditions !== undefined) {
                        for (var cond of lvli.Conditions) {
                            functionNames.set(cond.FunctionName, cond.FunctionName);
                        }
                    }
                    if (lvli.Entries !== undefined) {
                        for (var entry of lvli.Entries) {
                            if (entry.Conditions !== undefined) {
                                for (var cond of entry.Conditions) {
                                    functionNames.set(cond.FunctionName, cond.FunctionName);
                                }
                            }
                        }
                    }
                }

                for (var fn of functionNames) {
                    console.log(fn);
                }
                */
            }

            function loadScript(src, callback) {
                var r = false;
                var s = document.createElement('script');
                s.type = 'text/javascript';
                s.src = src;
                s.onload = s.onreadystatechange = function() {
                    //console.log( this.readyState ); //uncomment this line to see which ready states are called.
                    if ( !r && (!this.readyState || this.readyState == 'complete') ) {
                        r = true;
                        callback(s);
                    }
                };
                var t = document.getElementsByTagName('script')[0];
                t.parentNode.insertBefore(s, t);
            }

            function doLoad() {
                document.getElementById("loadversion").disabled = true;

                var versionSelect = document.getElementById("versionselect");
                if (versionSelect.selectedIndex >= 0) {
                    downloadDone = 4;
                    var patchPrefix = 
                        // "https://akarnokd.github.com/rng-76/" +
                        versionSelect.options[versionSelect.selectedIndex].value + "_";

                    loadScript("data/" + patchPrefix + "SeventySix_EDIDs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                    loadScript("data/" + patchPrefix + "SeventySix_GLOBs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                    loadScript("data/" + patchPrefix + "SeventySix_LVLIs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                    loadScript("data/" + patchPrefix + "SeventySix_CURVs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                }
            }


            document.getElementById("loadversion").onclick = doLoad;

            var infoMap = new Map();
            infoMap.set("ListSearch", 
                "Enter the FormID (leading zeros can be omitted) or Editor ID of the leveled list to find."
                + "<br>Use * to indicate a wildcard (e.g., *Fasnacht*)."
                + "<br>Use commas to list alternative options."
                + "<br>Spaces and capitalization are ignored."
            );
            infoMap.set("ItemSearch", 
                "Enter the FormID (leading zeros can be omitted) or Editor ID of the item you want to locate in the leveled lists."
                + "<br>Use * to indicate a wildcard (e.g., *Fixer*)."
                + "<br>Use commas to list alternative options."
                + "<br>Spaces between words are considered (e.g., *long coat*)."
                + "<br>Capitalization is ignored."
            );

            // add HTML explanation marker
            function info(name) {
                return "&nbsp;<sup><a href='#' style='font-size: 14; font-weight: bold;' onclick='showinfo(this, \"" + name + "\"); return false;'>Tip</a></sup>";
            }

            // popup for explanation
            function showinfo(target, name) {
                var div = document.getElementById("InfoDiv" + name);
                if (div == null) {
                    var div = document.createElement("div");
                    div.style.border = "1px solid black";
                    div.style.padding = "3px";
                    div.style.position = "absolute";
                    div.style.backgroundColor = "#FFFFD0";
                    div.style.zIndex = 99;
                    div.id = "InfoDiv" + name;
                    var txt = infoMap.get(name);

                    if (txt == null) {
                        txt = "??? " + name + " ???";
                    }
                    txt += "<hr><font style='font-size: 14px'>Click to close.</font>";
                    div.innerHTML = txt;

                    target.parentElement.appendChild(div);
                    div.onclick = function() {
                        target.parentElement.removeChild(div);
                    }
                } else {
                    target.parentElement.removeChild(div);
                }
            }

            document.getElementById("listsearchtip").innerHTML = "Search leveled list " + info("ListSearch");
            document.getElementById("itemsearchtip").innerHTML = "Search item in lists " + info("ItemSearch");

            // paging support
            var searchResults = [];

            function parseSearchText(text) {

                var result = text.split(",");
                for (var i = 0; i < result.length; i++) {
                    // remove spaces
                    var entry = result[i].trim();

                    entry = entry.replace(" ", "\\s");;
                    entry = entry.replace(/\*/g, ".*");
                    entry = entry.replace(/^0+/, "");
                    entry = entry.toLowerCase();

                    result[i] = new RegExp("^" + entry + "$");
                }

                return result;
            }

            function getEditorID(formID) {
                var result = edids[formID];
                if (result !== undefined) {
                    var idx = result.indexOf(" ", 4);
                    if (idx < 0) {
                        return result.substring(4);
                    }
                    return result.substring(4, idx);
                }
                return "";
            }

            function getDescription(formID) {
                var result = edids[formID];
                if (result !== undefined) {
                    var idx = result.indexOf(" ", 4);
                    if (idx > 0) {
                        return result.substring(idx + 1);
                    }
                }
                return "";
            }

            function getGroupID(formID) {
                var result = edids[formID];
                if (result !== undefined) {
                    return result.substring(0, 4);
                }
                return "";
            }

            function createListLink(formID, text) {
                return "<a href='#' onclick='showList(\"" + formID + "\"); return false;'>" + text + "</a>";
            }

            function interpolate(curveTable, x) {
                var first = curveTable[0];
                if (x <= first.x) {
                    return first.y;
                }
                var last = curveTable[curveTable.length - 1];
                if (last <= x) {
                    return last.y;
                }
                for (var i = 0; i < curveTable.length - 1; i++) {
                    var curr = curveTable[i];
                    var next = curveTable[i + 1];

                    if (curr.x <= x && x < next.x) {
                        var step = next.x - curr.x;
                        var raise = next.y - curr.y;

                        var xrate = (x - curr.x) / step;

                        var yrate = curr.y + raise * xrate;

                        return yrate;
                    }
                }
                return NaN;
            }

            function decodeValue(entry, keyDirect, keyGlobal, keyCurve) {
                var curveID = entry[keyCurve];
                var globalID = entry[keyGlobal];
                if (curveID !== undefined) {
                    var curveTable = curves[curveID];
                    if (curveTable !== undefined) {
                        if (globalID !== undefined) {
                            var x = getSettingsValue(globalID);
                            if (x === undefined) {
                                x = globals[globalID];
                            }
                            if (x !== undefined) {
                                var v = interpolate(curveTable, x);                            
                                return {
                                    type: "Curve",
                                    id: curveID,
                                    g: globalID,
                                    x: x,
                                    value: v
                                };
                            }

                            return {
                                type: "Curve",
                                id: curveID,
                                x: globalID,
                                error: "Global value not found"
                            };
                        }
                        return {
                            type: "Curve",
                            id: curveID,
                            error: "Global reference entry missing"
                        }
                    }
                    return {
                        type: "Curve",
                        id: curveID,
                        error: "Curve table not found."
                    }
                }
                if (globalID !== undefined) {
                    var x = getSettingsValue(globalID);
                    if (x === undefined) {
                        x = globals[globalID];
                    }
                    if (x !== undefined) {
                        return {
                            type: "Global",
                            id: globalID,
                            value: x
                        };
                    }
                    return {
                        type: "Global",
                        id: globalID,
                        error: "Global value not found"
                    }
                }

                var direct = entry[keyDirect];
                if (direct === undefined) {
                    direct = 0;
                }

                return {
                    type: "Constant",
                    value: direct
                };
            }

            function createNukaLink(formID) {
                return "<a href='https://nukacrypt.com/database/json/" + formID + "' target='_blank' title='" 
                    + getDescription(formID) + ". "
                    + "Click to see the Nukacrypt data.'>&#x2622;&nbsp;"
                    + getGroupID(formID) + ":" + formID + " &lt;" + getEditorID(formID) + "&gt;"
                    + "</a>";
            }

            function pickComboSettings(key, entry) {
                var input = settingsMap.get(key);
                if (input !== undefined) {
                    if (input.selectedIndex !== undefined) {
                        for (var i = 0; i < input.options.length; i++) {
                            var opt = input.options[i];
                            if (opt.value == entry) {
                                if (opt.selected) {
                                    opt.selected = false;
                                    input.options[0].selected = true;
                                } else {
                                    opt.selected = true;
                                }
                                input.dispatchEvent(new Event('input'));
                                break;
                            }
                        }
                    }
                }
                return false;
            }

            function isComboSelected(key, entry) {
                var input = settingsMap.get(key);
                if (input !== undefined) {
                    if (input.selectedIndex !== undefined) {
                        for (var i = 0; i < input.options.length; i++) {
                            var opt = input.options[i];
                            if (opt.value == entry && opt.selected) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function toggleCheckBoxSettings(key) {
                var input = settingsMap.get(key);
                if (input !== undefined) {
                    input.checked = !input.checked;
                    input.dispatchEvent(new Event('input'));
                }
            }

            function isCheckBoxSelected(key) {
                var input = settingsMap.get(key);
                return input !== undefined && input.checked;
            }

            function buildConditionEntry(parent, entry, maxCols) {
                if (entry.Conditions !== undefined) {
                    n = parent.rows.length;
                    row = parent.insertRow(n);
                    cll = row.insertCell(row.cells.length);
                    cll.colSpan = maxCols;
                    cll.style.paddingLeft = "60px";

                    var innerTbl = document.createElement("table");
                    innerTbl.style.width = "100%";
                    cll.appendChild(innerTbl);

                    row = innerTbl.insertRow(0);
                    cll = row.insertCell(0);
                    var checkTxt = "";

                    if (evaluateConditions(entry.Conditions)) {
                        checkTxt = "<span style='color: green; font-weight: bold'>[ &#128077; PASS ]</span>";
                    } else {
                        checkTxt = "<span style='color: red; font-weight: bold'>[ &#10060; FAIL ]</span>";
                    }

                    cll.innerHTML = "Conditions (" + entry.Conditions.length + ")&nbsp;&nbsp;&nbsp;" + checkTxt;

                    cll.style.backgroundColor = "#FFC0FF";
                    cll.style.fontWeight = "bold";

                    buildConditionItem(innerTbl, entry);
                }
            }

            var functionMap = new Map();

            // displayFunction: function(fn, cond) : string
            // settingsFunction: function(fn, cond) : void
            // evalFunction: function(fn, cond) : object
            function addFunction(name, displayFunction, settingsFunction, evalFunction) {
                var rec = {
                    display: displayFunction,
                    settings: settingsFunction,
                    evaluate: evalFunction
                };
                functionMap.set(name, rec);
                return rec;
            }

            var animSteps = 10;
            var animTime = 250;
            var currentAnim = undefined;
            var currentObj = undefined;

            function findTextBox(id) {
                var o = document.getElementById(id);
                o.scrollIntoView();
                flash(o, 0);
            }

            function flash(obj, n) {
                if (n == 0) {
                    if (currentAnim) {
                        clearTimeout(currentAnim);
                        currentObj.style.backgroundColor = "";
                    }
                    currentObj = obj;
                }
                if (n < animSteps && currentObj == obj) {
                    currentAnim = setTimeout(() => {
                        if ((n % 2) == 0) {
                            obj.style.backgroundColor = "#FFFF00"
                        } else {
                            obj.style.backgroundColor = "";
                        }
                        flash(obj, n + 1);
                    }, animTime);
                } else {
                    obj.style.backgroundColor = "";
                }
            }

            var displayOneLinkFunc = function(fn, cond) {
                return "(" + createNukaLink(cond.Param1Ref) + ")"
                ;
            };

            var displayOneLinkCheckFunc = function(fn, cond) {
                var clazz = "picker";
                var key = fn + "_" + cond.Param1Ref;
                if (isCheckBoxSelected(key)) {
                    clazz = "pickerOn";
                }
                return "(" + createNukaLink(cond.Param1Ref) + ")"
                + "&nbsp;<a href='#' onclick='javascript:toggleCheckBoxSettings(\"" + key
                + "\"); return false;' title='Toggle this condition' "
                + "class='" + clazz + "'>&#x2190;</a>"
                ;
            };

            var displayNoneCheckFunc = function(fn, cond) {
                var clazz = "picker";
                var key = fn;
                if (isCheckBoxSelected(key)) {
                    clazz = "pickerOn";
                }
                return "&nbsp;<a href='#' onclick='javascript:toggleCheckBoxSettings(\"" + fn
                + "\"); return false;' title='Toggle this condition' "
                + "class='" + clazz + "'>&#x2190;</a>"
                ;
            };
            var displayFindBox = function(fn, cond) {
                var clazz = "picker";
                var key = fn;
                return "&nbsp;<a href='#' onclick='javascript:findTextBox(\"" + fn
                + "\"); return false;' title='Find this texbox' "
                + "class='" + clazz + "'>#</a>"
                ;
            };

            var displayOneLinkPickFunc = function(fn, cond) {
                var clazz = "picker";
                if (isComboSelected(fn, cond.Param1Ref)) {
                    clazz = "pickerOn"
                }
                return "(" + createNukaLink(cond.Param1Ref) + ")"
                + "&nbsp;<a href='#' onclick='javascript:pickComboSettings(\"" + fn + "\", \"" + cond.Param1Ref
                + "\"); return false;' title='Use this in the settings. Click again to select N/A.' "
                + "class='" + clazz + "'>&#x2190;</a>"
                ;
            };

            var displayPickDayOfWeekFunc = function(fn, cond) {
                return "&nbsp;<a href='#' onclick='javascript:pickComboSettings(\"" + fn + "\", \"" + cond.Value
                + "\"); return false;' title='Use this day of week' "
                + "class='picker'>&#x2190;</a>"
                ;
            };

            var displayTwoLinksFunc = function(fn, cond) {
                return "("
                     + createNukaLink(cond.Param1Ref)
                     + ", "
                     + createNukaLink(cond.Param2Ref)
                     + ")";
            };

            var displayLinkAndIntFunc = function(fn, cond) {
                return "("
                     + createNukaLink(cond.Param1Ref)
                     + ", "
                     + parseInt(cond.Param2Ref, 16)
                     + ")";
            };

            // Checkboxes
            // ==========
            var addCheckBoxFunc = function(fn, cond) {
                appendCheckBox(fn, cond.Param1Ref);
            };
            var addCheckBoxValue = function(fn, cond) {
                appendCheckBoxValue(fn);
            };
            var addCheckBoxRefIntFunc = function(fn, cond) {
                appendCheckBoxRefInt(fn, cond);
            };

            // Comboboxes
            // ==========
            var addComboBoxFunc = function(fn, cond) {
                appendComboBox(fn, cond.Param1Ref);
            };
            var addComboBoxParam2IntFunc = function(fn, cond) {
                appendComboBoxParam2Int(fn, cond.Param1Ref, parseInt(cond.Param2Ref, 16));
            };

            var dayOfWeekComboBoxFunc = function(fn, cond) {
                appendComboBoxDayOfWeek(fn);
            }

            // Texboxes
            // ========

            var addTextBoxFunc = function(fn, cond) {
                appendTextBox(cond, "Param1Ref", true);
            };
            var addTextBoxValueFunc = function(fn, cond) {
                appendTextBoxValue(fn);
            };
            var addTextBoxParamFunc = function(fn, cond) {
                appendTextBoxParam(fn, cond.Param1Ref, false);
            };
            var addTextBoxParamFunc2 = function(fn, cond) {
                appendTextBoxParam2(fn, cond.Param1Ref, cond.Param2Ref);
            };
            var addTextBoxNameParamFunc = function(fn, cond) {
                appendTextBoxParam(fn, cond.Param1Ref, true);
            };

            // oooooooooooooooooooooooooooooooooooooo

            var evalCheckBoxFunc = function(fn, cond) {
                return getSettingsValue(fn + "_" + cond.Param1Ref);
            };

            var evalCheckBoxValue = function(fn, cond) {
                return getSettingsValue(fn);
            };

            var evalComboBoxFunc = function(fn, cond) {
                var selectOption = getSettingsValue(fn);
                return selectOption == cond.Param1Ref;
            };

            var evalTextBox = function(fn, cond) {
                return getSettingsValue(cond.Param1Ref);
            };
            var evalTextBoxValue = function(fn, cond) {
                return getSettingsValue(fn);
            };
            var evalTextBoxRefRef = function(fn, cond) {
                return getSettingsValue(cond.Param1Ref + "_" + cond.Param2Ref);
            };

            var evalCheckBoxFuncRefRef = function(fn, cond) {
                return getSettingsValue(fn + "_" + cond.Param1Ref + "_" + cond.Param2Ref);
            };

            // Presence/absence based on a key by reference
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            addFunction("HasLearnedRecipe", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("EditorLocationHasKeyword", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("GetQuestCompleted", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("HasEntitlement", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("WornHasKeyword", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("IsTrueForConditionForm", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("HasPerk", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("HasKeyword", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("HasActiveMagicEffect", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("GetEquipped", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);
            addFunction("PlayerHasQuest", displayOneLinkCheckFunc, addCheckBoxFunc, evalCheckBoxFunc);

            // A global value keyed by its ID
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            addFunction("GetGlobalValue", displayOneLinkFunc, addTextBoxFunc, evalTextBox);

            // Direct numeric value on subject/target
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            addFunction("GetStage", displayFindBox, addTextBoxValueFunc, evalTextBoxValue);
            addFunction("GetLockLevel", displayFindBox, addTextBoxValueFunc, evalTextBoxValue);
            addFunction("GetWorldType", displayFindBox, addTextBoxValueFunc, evalTextBoxValue);

            // Value on the subject/target keyed by the reference
            addFunction("GetActorValue", displayOneLinkFunc, addTextBoxParamFunc, evalTextBox);
            addFunction("GetItemCount", displayOneLinkFunc, addTextBoxParamFunc, evalTextBox);
            addFunction("GetNumTimesCompletedQuest", displayOneLinkFunc, addTextBoxParamFunc, evalTextBox);
            addFunction("GetDistance", displayOneLinkFunc, addTextBoxNameParamFunc, evalTextBox);

            // Value on the subject target, keyed by the reference, that can be only a set of possibilities
            addFunction("GetIsInRegion", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            addFunction("GetIsRace", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            addFunction("LocationHasRefType", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            addFunction("GetIsID", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            addFunction("GetInCurrentLoc", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            addFunction("HasRefType", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            addFunction("GetIsEditorLocation", displayOneLinkPickFunc, addComboBoxFunc, evalComboBoxFunc);
            

            // Boolean value on subject/target
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            addFunction("GetLocked", displayNoneCheckFunc, addCheckBoxValue, evalCheckBoxValue);
            addFunction("IsActivePlayer", displayNoneCheckFunc, addCheckBoxValue, evalCheckBoxValue);
            addFunction("LocationHasPlayerOwnedWorkshop", displayNoneCheckFunc, addCheckBoxValue, evalCheckBoxValue);
            addFunction("IsInInterior", displayNoneCheckFunc, addCheckBoxValue, evalCheckBoxValue);
            
            // Special cases
            addFunction("GetRandomPercent", undefined, undefined, (fn, cond) => cond.conditionRandom);

            addFunction("GetLevel", undefined, undefined, (fn, cond) => getSettingsValue("MinLevel"));

            addFunction("GetActorValueForCurrentLocation", displayTwoLinksFunc, addTextBoxParamFunc2, evalTextBoxRefRef);

            addFunction("GetStageDoneUniqueQuest", displayLinkAndIntFunc, addCheckBoxRefIntFunc, evalCheckBoxFuncRefRef);

            addFunction("GetDayOfWeek", displayPickDayOfWeekFunc, dayOfWeekComboBoxFunc, evalTextBoxValue);

            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            function buildConditionItem(innerTbl, entry) {
                var i = 0;
                for (var cond of entry.Conditions) {
                    row = innerTbl.insertRow(innerTbl.rows.length);
                    cll = row.insertCell(0);

                    cll.style.backgroundColor = "E0E0E0";

                    var fn = cond.FunctionName;
                    var txt = "&nbsp;&nbsp;&nbsp;<b>" + fn + "</b>";

                    var handle = functionMap.get(fn);
                    if (handle != null && handle.display !== undefined) {
                        txt += handle.display(fn, cond);
                    }

                    var operatorKind = (cond.Operator & 0xFF) >> 5;
                    if (operatorKind == 0) {
                        txt += "&nbsp;==&nbsp;"
                    }
                    if (operatorKind == 1) {
                        txt += "&nbsp;!=&nbsp;"
                    }
                    if (operatorKind == 2) {
                        txt += "&nbsp;&gt;&nbsp;"
                    }
                    if (operatorKind == 3) {
                        txt += "&nbsp;>=&nbsp;"
                    }
                    if (operatorKind == 4) {
                        txt += "&nbsp;&lt;&nbsp;"
                    }
                    if (operatorKind == 5) {
                        txt += "&nbsp;&lt;=&nbsp;"
                    }

                    if (cond.Value !== undefined) {
                        txt += "<b>" + cond.Value + "</b>";
                    } else {
                        txt += "<b>" + globals[cond.Ref] + "</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(" + createNukaLink(cond.Ref) + ")";
                    }


                    cll.innerHTML = txt;

                    if (entry.Conditions.length > 1 && i < entry.Conditions.length - 1) {
                        row = innerTbl.insertRow(innerTbl.rows.length);
                        cll = row.insertCell(0);
                        cll.style.textAlign = "center";
                        cll.style.fontWeight = "bold";

                        if ((cond.Operator & 1) == 0) {
                            cll.innerText = "{ AND }";
                        } else {
                            cll.innerText = "{ OR }";
                        }

                    }
                    i++;
                }
            }

            function buildValueEntry(parent, omiss, maxCols, title, formatter, globalPrefix) {
                n = parent.rows.length;
                row = parent.insertRow(n);
                cll = row.insertCell(row.cells.length);
                cll.colSpan = maxCols;
                cll.style.paddingLeft = "60px";

                var innerTbl = document.createElement("table");
                innerTbl.style.borderCollapse = "collapse";
                innerTbl.style.width = "100%";
                cll.appendChild(innerTbl);

                row = innerTbl.insertRow(0);
                cll = row.insertCell(0);

                cll.style.backgroundColor = "C0FFC0";

                var omissSpacer = "<br><span style='margin-left: 20px;'></span>";

                if (omiss.type === "Constant") {
                    cll.innerHTML = title + " (constant): <b>" + formatter(omiss.value) + "</b>";
                }
                else if (omiss.type === "Global") {
                    if (omiss.error === undefined) {
                        cll.innerHTML = title + " (global): <b>" + formatter(omiss.value) + "</b>" + omissSpacer
                            + createNukaLink(omiss.id)
                            + displayFindBox(globalPrefix + "_" + omiss.id)
                        ;
                    } else {
                        cll.innerHTML = title + " (global): <b style='color: red;'>" + omiss.error + "</b>" + omissSpacer
                            + createNukaLink(omiss.id)
                            + displayFindBox(globalPrefix + "_" + omiss.id)
                        ;
                    }
                }
                else if (omiss.type == "Curve") {
                    if (omiss.error === undefined) {
                        cll.innerHTML = title + " (curve): <b>" + formatter(omiss.value) + "</b>" + omissSpacer
                            + "Table: " + createNukaLink(omiss.id) + omissSpacer
                            + "Global: " + createNukaLink(omiss.g)
                            + displayFindBox(globalPrefix + "_" + omiss.g)
                            + " = " + omiss.x
                        ;
                    } else {
                        cll.innerHTML = title + " (curve): <b style='color: red;'>" + omiss.error + "</b>" + omissSpacer
                            + "Table: " + createNukaLink(omiss.id)
                            + "Global: " + createNukaLink(omiss.g)
                            + displayFindBox(globalPrefix + "_" + omiss.g)
                        ;
                    }
                }
            }

            function compareEntries(curr, prev) {
                return curr.Object === prev.Object 
                       && curr.LVIV === prev.LVIV
                       && curr.LVIG === prev.LVIG
                       && curr.LVOV === prev.LVOV
                       && curr.LVOC === prev.LVOC 
                       && curr.LVOT === prev.LVOT
                       && curr.LVLV === prev.LVLV
                       && (curr.Conditions === undefined && prev.Conditions === undefined);
            }

            function currentPatch() {
                var patchSel = document.getElementById("versionselect");
                return patchSel.options[patchSel.selectedIndex].value;
            }

            function prepareLinkDefault(patch) {

                var lnk = "?patch=" + patch;
                if (!document.getElementById("Coalesce").checked) {
                    lnk += "&nocoalesce";
                }
                if (!document.getElementById("ShowFailedConditions").checked) {
                    lnk += "&noshowfail";
                }
                return lnk;
            }

            function createOpenNewWindow(formID) {
                var lnk = prepareLinkDefault(currentPatch());
                lnk += "&formids=" + encodeURIComponent(formID);

                return "<a href='" + lnk + "' target='_blank' title='Open in new window' style='font-weight: bold; border: 1px solid blue;'>&nbsp;&#x2197;&nbsp;</a>"
            }
            
            function generateTable(parent, formIDs, index, chanceNode, parentChance) {
                var formID = formIDs[index];

                var lvli = leveledLists[formID];
                var maxCols = 5;

                var n = parent.rows.length;
                var row = parent.insertRow(n);
                var cll = row.insertCell(row.cells.length);
                cll.innerHTML = getGroupID(formID) + ":" + formID + " &lt;" + getEditorID(formID) + "&gt; "
                    + "<a href='https://nukacrypt.com/database/json/" + formID + "' target='_blank' title='" 
                    + getDescription(formID)
                    + ". Click to see Nukacrypt data.'>&#x2622;</a>"
                    + "&nbsp;" + createOpenNewWindow(formID)
                ;
                cll.style.backgroundColor = "#FFCC00";
                cll.style.fontWeight = "bold";
                cll.colSpan = maxCols;

                if (lvli === undefined) {
                    n = parent.rows.length;
                    row = parent.insertRow(n);
                    cll = row.insertCell(row.cells.length);

                    cll.innerText = "Table " + formID + " not found.";
                } else {
                    var omissChanceList = decodeValue(lvli, "LVCV", "LVLG", "LVCT");
                    buildValueEntry(parent, omissChanceList, maxCols, "Omission chance", value => value.toFixed(3) + "%", "LVLG");

                    var maxValueList = decodeValue(lvli, "LVMV", "LVMG", "LVMT");
                    buildValueEntry(parent, maxValueList, maxCols, "Max value", value => value + "", "LVMG");
                    var flagsList = lvli["LVLF"];

                    n = parent.rows.length;
                    row = parent.insertRow(n);
                    cll = row.insertCell(row.cells.length);
                    cll.style.paddingLeft = "60px";
                    cll.colSpan = maxCols;
                    
                    var innerTbl = document.createElement("table");
                    innerTbl.style.borderCollapse = "collapse";
                    innerTbl.style.width = "100%";
                    cll.appendChild(innerTbl);

                    row = innerTbl.insertRow(0);
                    cll = row.insertCell(0);
                    cll.style.backgroundColor = "C0FFC0";
                    var flagsTxt = "Flags (" + flagsList + "): ";

                    if (isFlagsAll(flagsList)) {
                        flagsTxt += "<b>+all</b> "
                    } else {
                        if ((flagsList & 1) != 0) {
                            flagsTxt += "<b>+all-levels</b> "
                        } else {
                            flagsTxt += "<b>+closest-levels</b> "
                        }
                        if (isFlagsEach(flagsList)) {
                            flagsTxt += "<b>+parent-quantity-randomly</b> "
                        } else {
                            flagsTxt += "<b>+one-randomly</b> "
                        }
                    }
                    if ((flagsList & 8) != 0) {
                        flagsTxt += "<b>+u3</b> "
                    }
                    if ((flagsList & 16) != 0) {
                        flagsTxt += "<b>+refspawn</b> "
                    }
                    if ((flagsList & 32) != 0) {
                        flagsTxt += "<b>+u5</b> "
                    }
                    if ((flagsList & 64) != 0) {
                        flagsTxt += "<b>+first-match-all-conditons</b> "
                    }
                    if ((flagsList & 128) != 0) {
                        flagsTxt += "<b>+u7</b> "
                    }


                    cll.innerHTML = flagsTxt;

                    if (lvli.Parents !== undefined) {
                        var n = parent.rows.length;
                        var row = parent.insertRow(n);
                        var cll = row.insertCell(row.cells.length);
                        cll.colSpan = maxCols;
                        cll.innerText = "Referenced from (" + lvli.Parents.length + ")";
                        cll.style.backgroundColor = "#C0FFFF";
                        cll.style.fontWeight = "bold";

                        for (var ref of lvli.Parents) {
                            n = parent.rows.length;
                            row = parent.insertRow(n);

                            cll = row.insertCell(row.cells.length);

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            cll.innerHTML = createListLink(ref, ref);

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            cll.innerHTML = createListLink(ref, getEditorID(ref));

                            cll = row.insertCell(row.cells.length);
                            cll.innerHTML = "<a href='https://nukacrypt.com/database/json/" + ref + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>"
                                + "&nbsp;" + createOpenNewWindow(ref);

                            cll = row.insertCell(row.cells.length);

                            var btn = document.createElement("button");
                            cll.appendChild(btn);

                            btn.innerText = "Chain";

                            let newFormIDs = [];
                            newFormIDs.push(ref);
                            for (var fi = index; fi < formIDs.length; fi++) {
                                newFormIDs.push(formIDs[fi]);
                            }

                            btn.onclick = function() {
                                showChain(newFormIDs);
                            };
                            if (index > 0 && formIDs[index - 1] == ref) {
                                btn.disabled = true;
                            }
                        }
                    }

                    if (lvli.Conditions !== undefined) {
                        n = parent.rows.length;
                        row = parent.insertRow(n);
                        cll = row.insertCell(row.cells.length);

                        var checkTxt = "";

                        if (evaluateConditions(lvli.Conditions)) {
                            checkTxt = "<span style='color: green; font-weight: bold'>[ &#128077; PASS ]</span>";
                        } else {
                            checkTxt = "<span style='color: red; font-weight: bold'>[ &#10060; FAIL ]</span>";
                        }

                        cll.innerHTML = "Conditions (" + lvli.Conditions.length + ")&nbsp;&nbsp;&nbsp;" + checkTxt;
                        cll.style.backgroundColor = "#C0C0FF";
                        cll.style.fontWeight = "bold";
                        cll.colSpan = maxCols;

                        n = parent.rows.length;
                        row = parent.insertRow(n);
                        cll = row.insertCell(row.cells.length);
                        cll.colSpan = maxCols;
                        var innerTbl = document.createElement("table");
                        innerTbl.style.width = "100%";
                        innerTbl.style.paddingLeft = "20px";
                        cll.appendChild(innerTbl);

                        row = innerTbl.insertRow(0);
                        cll = row.insertCell(0);

                        buildConditionItem(innerTbl, lvli);
                    }
                    if (lvli.Entries !== undefined) {

                        var max = maxValueList.value;

                        n = parent.rows.length;
                        row = parent.insertRow(n);
                        cll = row.insertCell(row.cells.length);

                        var showFail = document.getElementById("ShowFailedConditions").checked;

                        if (!showFail) {
                            cll.innerText = "Entries (" + lvli.Entries.length + ") - showing passing entries only";
                        } else {
                            cll.innerText = "Entries (" + lvli.Entries.length + ")";
                        }
                        cll.style.backgroundColor = "#C0C0FF";
                        cll.style.fontWeight = "bold";
                        cll.colSpan = maxCols;
                        var entries = [];

                        // mark entry indexes to match the chance tree
                        var idx = 0;
                        for (var e of lvli.Entries) {
                            e.index = idx++;
                        }

                        // coalesce same entries
                        if (document.getElementById("Coalesce").checked) {
                            var entriesCopy = JSON.parse(JSON.stringify(lvli.Entries));

                            for (var i = entriesCopy.length - 1; i > 0; i--) {
                                var curr = entriesCopy[i];
                                if (curr.coalesced === undefined) {
                                    curr.coalesced = 1;
                                }
                                if (curr.LVIV === undefined) {
                                    curr.LVIV = 1;
                                }
                                for (var j = i - 1; j >= 0; j--) {
                                    var prev = entriesCopy[j];
                                    if (prev.coalesced === undefined) {
                                        prev.coalesced = 1;
                                    }
                                    if (prev.LVIV === undefined) {
                                        prev.LVIV = 1;
                                    }

                                    if (compareEntries(curr, prev)) {
                                        curr.ignore = true;
                                        prev.coalesced += curr.coalesced;
                                        break;
                                    }
                                }
                            }

                            for (var e of entriesCopy) {
                                if (!e.ignore) {
                                    entries.push(e);
                                }
                            }
                        } else {
                            entries = lvli.Entries;
                        }

                        let settingsLevel = getSettingsValue("MinLevel");
                        let isClosestLevel = (lvli.LVLF & 5) == 0;
                        var closestLevel = 0;

                        if (isClosestLevel) {
                            for (var entry of entries) {
                                if (entry.Conditions === undefined || evaluateConditions(entry.Conditions)) {
                                    var lvl = decodeValueOverride(entry, "LVLV", "LVOG", "ZZZZ");
                                    if (lvl <= settingsLevel) {
                                        closestLevel = Math.max(closestLevel, lvl);
                                    }
                                }
                            }
                        }

                        for (var entry of entries) {
                            var entryIndex = entry.index;
                            if (!showFail) {
                                var pass = entry.Conditions === undefined || evaluateConditions(entry.Conditions);
                                var lvl = decodeValueOverride(entry, "LVLV", "LVOG", "ZZZZ");
                                if (!pass || (!isClosestLevel && lvl > settingsLevel) || (closestLevel && lvl != closestLevel)) {
                                    continue;
                                }
                            }

                            n = parent.rows.length;
                            row = parent.insertRow(n);

                            var objectID = entry.Object;
                            var objectEDIDFull = edids[objectID];
                            var objectGroup = "";
                            var objectName = "";
                            var objectDesc = undefined;
                            if (objectEDIDFull !== undefined) {
                                objectGroup = objectEDIDFull.substring(0, 4);
                                var didx = objectEDIDFull.indexOf(" ", 4);
                                if (didx >= 0) {
                                    objectName = objectEDIDFull.substring(4, didx);
                                    objectDesc = objectEDIDFull.substring(didx + 1);
                                } else {
                                    objectName = objectEDIDFull.substring(4);
                                }
                            }

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            cll.innerText = objectGroup;

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            if (objectGroup == "LVLI") {
                                cll.innerHTML = createListLink(objectID, objectID);
                            } else {
                                cll.innerText = objectID;
                            }

                            cll = row.insertCell(row.cells.length);
                            if (objectGroup == "LVLI") {
                                cll.innerHTML = createListLink(objectID, objectName);
                            } else {
                                if (objectDesc !== undefined) {
                                    cll.innerHTML = "<span class='monospaced'>" + objectName + "</span>"
                                    + "&nbsp;&nbsp;<b>\"" + objectDesc + "\"</b>";
                                    ;
                                } else {
                                    cll.style.fontFamily = "monospace";
                                    cll.innerText = objectName;
                                }
                            }
                            var qty = decodeValueOverride(entry, "LVIV", "LVIG", "ZZZZ");
                            if (qty > 1) {
                                cll.innerHTML += "&nbsp;<span style='color: blue; font-weight: bold; border: 1px dotted blue;'>&nbsp;x&nbsp;" + qty + "&nbsp;</span>";
                            }

                            cll = row.insertCell(row.cells.length);
                            cll.innerHTML = "<a href='https://nukacrypt.com/database/json/" + objectID + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>";

                            if (objectGroup == "LVLI") {
                                cll.innerHTML += "&nbsp;" + createOpenNewWindow(objectID);

                                cll = row.insertCell(row.cells.length);
                                var btn = document.createElement("button");
                                btn.innerText = "Open";
                                cll.appendChild(btn);

                                let newFormIDs = [];
                                for (var fi = 0; fi <= index; fi++) {
                                    newFormIDs.push(formIDs[fi]);
                                }
                                newFormIDs.push(objectID);
                                btn.onclick = function() {
                                    currentFormIDs = newFormIDs;
                                    renderTable(newFormIDs);
                                };
                            }

                            var omissChanceEntry = decodeValue(entry, "LVOV", "LVOC", "LVOT");
                            buildValueEntry(parent, omissChanceEntry, maxCols, "Omission chance", value => value.toFixed(3) + "%", "LVOC");
                            var levelEntry = decodeValue(entry, "LVLV", "LVOG", "ZZZZ");
                            if (levelEntry.value > 1 || closestLevel) {
                                buildValueEntry(parent, levelEntry, maxCols, "Minimum level", value => {
                                    if (!closestLevel) {
                                        if (value <= settingsLevel) {
                                            return value;
                                        }
                                    }
                                    if (value === closestLevel) {
                                        return value;
                                    }
                                    
                                    return value + " [ &#10060; FAIL ]";
                                }, "LVOG");
                            }

                            if (entry.LVIG !== undefined) {
                                var qtyEntry = decodeValue(entry, "LVIV", "LVIG", "ZZZZ");
                                buildValueEntry(parent, qtyEntry, maxCols, "Quantity", value => value, "LVIG");
                            }

                            buildConditionEntry(parent, entry, maxCols);

                            n = parent.rows.length;
                            row = parent.insertRow(n);
                            cll = row.insertCell(row.cells.length);
                            cll.colSpan = 2;

                            cll = row.insertCell(row.cells.length);
                            cll.colSpan = Math.max(1, maxCols - 3);


                            var itemNode = chanceNode.items[entryIndex];
                            var entrySelfChance = itemNode.chance;
                            var entryChance = 0;
                            var coalesced = entry.coalesced !== undefined ? entry.coalesced : 1;

                            var chanceTable = document.createElement("table");
                            cll.appendChild(chanceTable);
                            chanceTable.style.width = "100%";

                            row = chanceTable.insertRow(0);
                            cll = row.insertCell(0)
                            cll.style.fontWeight = "bold";
                            if (coalesced > 1) {
                                cll.innerHTML = "Drop chance (<span style='border: 1px dotted green; font-weight: bold; color: green;'>&nbsp;"
                                 + coalesced + "&nbsp;</span> <span title='This entry appeared multiple times and has been coalesced into one row.'>&#x1F5DC;</span>)";
                            } else {
                                cll.innerText = "Drop chance";
                            }

                            cll = row.insertCell(1)
                            cll.style.fontWeight = "bold";
                            cll.width = '100px';
                            if (entrySelfChance !== undefined) {
                                cll.style.textAlign = "right";
                                entryChance = entrySelfChance * parentChance * coalesced;
                                cll.innerText = (entryChance * 100.0).toFixed(3) + "%";
                            } else {
                                cll.style.textAlign = "center";
                                cll.innerText = "N/A";
                            }
                            cll.style.border = "1px dotted red";
                            cll.style.color = "red";

                            if (objectGroup == "LVLI" && formIDs.length > index + 1 && formIDs[index + 1] == objectID) {
                                n = parent.rows.length;
                                row = parent.insertRow(n);

                                cll = row.insertCell(row.cells.length);
                                cll.colSpan = maxCols;
                                cll.style.paddingLeft = "40px";
                                cll.style.border = "1px solid black";

                                var innerTable = document.createElement("table");
                                cll.appendChild(innerTable);

                                var cascadeChance = entryChance;
                                if (itemNode.apriori !== undefined) {
                                    cascadeChance = parentChance * itemNode.apriori;
                                }
                                generateTable(innerTable, formIDs, index + 1, itemNode.sublist, cascadeChance);

                                btn.innerText = "Close";
                                let closeFormIDs = formIDs.slice(0, index + 1);
                                btn.onclick = function() {
                                    currentFormIDs = closeFormIDs;
                                    renderTable(closeFormIDs);
                                };
                            }
                        }
                    }
                }
            }

            // string key (function name or FormID) to its HTML control
            var settingsMap = new Map();

            var settingsCheckboxes = document.getElementById("settingsCheckboxes");
            var settingsComboboxes = document.getElementById("settingsComboboxes");
            var settingsGlobals = document.getElementById("settingsGlobals");

            function gatherSettings(rootFormID) {
                settingsCheckboxes.innerHTML = "";
                settingsComboboxes.innerHTML = "";
                settingsGlobals.innerHTML = "";
                settingsMap.clear();

                var lvli = leveledLists[rootFormID];

                appendLevelInput();
                gatherSettingsEntry(lvli);

                for (var input of settingsMap.values()) {
                    input.oninput = function() {
                        updateChances(currentFormIDs);
                    };

                    if (input.selectedIndex !== undefined) {
                        if (input.dontSort === undefined) {
                            sortComboBox(input);
                        }
                    }
                }
            }

            function sortComboBox(input) {
                var items = [ { text: "", value: "" } ];

                for (var i = 1; i < input.options.length; i++) {
                    var opt = input.options[i];
                    items.push( { text: opt.text, value: opt.value });
                }

                items.sort((a, b) => a.text.localeCompare(b.text));
                for (var i = 1; i < input.options.length; i++) {
                    var opt = input.options[i];
                    var sorted = items[i];
                    
                    opt.text = sorted.text;
                    opt.value = sorted.value;
                }
            }

            var propertyNames = {
                "LVLV": "Minimum level"
            }

            function appendTextBoxValue(id) {
                if (settingsMap.get(id) != null) {
                    return;
                }

                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                span.innerHTML = id + "&nbsp;&nbsp;";

                var input = document.createElement("input");
                span.appendChild(input);
                input.id = id;
                input.type = "text";
                input.style.width = "70px";
                input.value = 0;

                var span2 = document.createElement("br");
                span.appendChild(span2);

                settingsMap.set(id, input);
            }

            function appendTextBoxParam(node, key, showFunctionName) {
                
                var id = key;
                if (settingsMap.get(id) != null) {
                    return;
                }

                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                if (showFunctionName) {
                    span.innerHTML = node + " (" + createNukaLink(key) + ")&nbsp;&nbsp;";
                } else {
                    span.innerHTML = createNukaLink(key) + "&nbsp;&nbsp;";
                }

                var input = document.createElement("input");
                span.appendChild(input);
                input.type = "text";
                input.style.width = "70px";
                input.id = key;
                input.value = 0;

                var span2 = document.createElement("br");
                span.appendChild(span2);

                settingsMap.set(id, input);
            }

            function appendTextBoxParam2(node, key1, key2) {
                
                var id = key1 + "_" + key2;
                if (settingsMap.get(id) != null) {
                    return;
                }

                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                span.innerHTML = "(" + createNukaLink(key1)
                    + ", "
                    + createNukaLink(key2)
                    + ")&nbsp;&nbsp;";

                var input = document.createElement("input");
                span.appendChild(input);
                input.type = "text";
                input.style.width = "70px";
                input.id = id;
                input.value = 0;

                var span2 = document.createElement("br");
                span.appendChild(span2);

                settingsMap.set(id, input);
            }

            function appendTextBox(node, key, isRef) {
                
                var id = isRef ? node[key] : key;
                if (settingsMap.get(id) != null) {
                    return;
                }

                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                if (isRef) {
                    span.innerHTML = createNukaLink(node[key]) + "&nbsp;&nbsp;";
                } else {
                    span.innerHTML = (propertyNames[key] !== undefined ? propertyNames[key] : key)  + "&nbsp;&nbsp;";
                }

                var input = document.createElement("input");
                span.appendChild(input);
                input.type = "text";
                input.style.width = "70px";
                input.id = isRef ? key + "_" + node[key] : key;
                input.value = isRef ? globals[node[key]] : node[key];

                var span2 = document.createElement("span");
                span.appendChild(span2);
                span2.innerHTML = "&nbsp;(" + input.value + ")<br>";

                settingsMap.set(id, input);
            }
            function appendCheckBoxRefInt(functionName, cond) {
                var key = functionName + "_" + cond.Param1Ref + "_" + cond.Param2Ref;
                var input = settingsMap.get(key);
                if (input == null) {
                    var span = document.createElement("span");
                    settingsCheckboxes.appendChild(span);

                    input = document.createElement("input");
                    span.appendChild(input);
                    input.type = "checkbox";
                    input.id = key;

                    var lbl = document.createElement("label");
                    span.appendChild(lbl);
                    lbl.htmlFor = key;
                    lbl.innerHTML = "&nbsp;" + functionName + ":&nbsp;";

                    var span2 = document.createElement("span");
                    span.appendChild(span2);
                    span2.innerHTML = 
                        "("
                        + createNukaLink(cond.Param1Ref)
                        + ", "
                        + parseInt(cond.Param2Ref, 16)
                        + ")<br>";

                    settingsMap.set(key, input);
                }
            }

            function appendCheckBox(functionName, value) {
                var key = functionName + "_" + value;
                var input = settingsMap.get(key);
                if (input == null) {
                    var span = document.createElement("span");
                    settingsCheckboxes.appendChild(span);

                    input = document.createElement("input");
                    span.appendChild(input);
                    input.type = "checkbox";
                    input.id = key;

                    var lbl = document.createElement("label");
                    span.appendChild(lbl);
                    lbl.htmlFor = key;
                    lbl.innerHTML = "&nbsp;" + functionName + ":&nbsp;";

                    var span2 = document.createElement("span");
                    span.appendChild(span2);
                    span2.innerHTML = createNukaLink(value) + "<br>";

                    settingsMap.set(key, input);
                }
            }

            function appendCheckBoxValue(functionName) {
                var key = functionName;
                var input = settingsMap.get(key);
                if (input != null) {
                    return;
                }
                var span = document.createElement("span");
                settingsCheckboxes.appendChild(span);

                input = document.createElement("input");
                span.appendChild(input);
                input.type = "checkbox";
                input.id = key;

                var lbl = document.createElement("label");
                span.appendChild(lbl);
                lbl.htmlFor = key;
                lbl.innerHTML = "&nbsp;" + functionName;

                var span2 = document.createElement("br");
                span.appendChild(span2);

                settingsMap.set(key, input);
            }

            function appendComboBox(functionName, value) {

                var input = settingsMap.get(functionName);
                if (input == null) {

                    var span = document.createElement("span");
                    settingsComboboxes.appendChild(span);
                    span.innerHTML = functionName + "&nbsp;&nbsp;"
                    
                    input = document.createElement("select");
                    span.appendChild(input);

                    var defaultOp = document.createElement("option");
                    input.add(defaultOp);
                    defaultOp.text = "N/A";
                    defaultOp.value = "";
                    defaultOp.selected = true;

                    var span2 = document.createElement("span");
                    span.appendChild(span2);
                    span2.innerHTML = "&nbsp;&nbsp;";

                    var a = document.createElement("a");
                    span.appendChild(a);
                    a.innerHTML = "&#x2622;"
                    a.href = "#";

                    let finput = input;
                    a.onclick = function() {
                        var entry = finput.options[finput.selectedIndex].value;
                        if (entry !== "") {
                            window.open("https://nukacrypt.com/database/json/" + entry, "_blank");
                        }
                        return false;
                    };

                    var span3 = document.createElement("br");
                    span.appendChild(span3);

                    settingsMap.set(functionName, input);
                }

                for (var op of input.options) {
                    if (op.value === value) {
                        return;
                    }
                }

                var opt = document.createElement("option");
                input.add(opt);
                opt.text = getGroupID(value) + ":" + value + " <" + getEditorID(value) + ">";
                opt.value = value;
            }

            function appendComboBoxParam2Int(functionName, key, value) {

                var id = functionName + "_" + key;
                var input = settingsMap.get(id);
                if (input == null) {

                    var span = document.createElement("span");
                    settingsComboboxes.appendChild(span);
                    span.innerHTML = functionName 
                        + "("
                        + createNukaLink(key)
                        + ")&nbsp;&nbsp;"
                    
                    input = document.createElement("select");
                    span.appendChild(input);

                    var defaultOp = document.createElement("option");
                    input.add(defaultOp);
                    defaultOp.text = "N/A";
                    defaultOp.value = "";
                    defaultOp.selected = true;

                    var span3 = document.createElement("br");
                    span.appendChild(span3);

                    settingsMap.set(id, input);
                }

                for (var op of input.options) {
                    if (op.value === value) {
                        return;
                    }
                }

                var opt = document.createElement("option");
                input.add(opt);
                opt.text = value;
                opt.value = value;
            }

            function appendComboBoxDayOfWeek(id) {

                var input = settingsMap.get(id);
                if (input == null) {

                    var span = document.createElement("span");
                    settingsComboboxes.appendChild(span);
                    span.innerHTML = id 
                        + "&nbsp;&nbsp;"
                    
                    input = document.createElement("select");
                    input.dontSort = true;
                    span.appendChild(input);

                    var span3 = document.createElement("br");
                    span.appendChild(span3);

                    var daysOfWeek = [ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ];
                    for (var i = 0; i < daysOfWeek.length; i++) {
                        var opt = document.createElement("option");
                        input.add(opt);
                        opt.text = daysOfWeek[i];
                        opt.value = i;
                        opt.selected = i == 0;
                    }

                    settingsMap.set(id, input);
                }

            }

            function appendLevelInput() {
                
                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                span.innerHTML = "Player/Target level&nbsp;&nbsp;";

                var input = document.createElement("input");
                span.appendChild(input);
                input.type = "number";
                input.min = 1;
                input.style.width = "80px";
                input.id = "MinLevel";
                input.value = 1;

                var span2 = document.createElement("br");
                span.appendChild(span2);

                settingsMap.set("MinLevel", input);
            }

            function gatherSettingsEntry(node) {

                // omission chance global
                if (node.LVLG !== undefined) {
                    appendTextBox(node, "LVLG", true);
                }
                // entry omission chance global
                if (node.LVOC !== undefined) {
                    appendTextBox(node, "LVOC", true);
                }

                // entry min level global
                if (node.LVOG !== undefined) {
                    appendTextBox(node, "LVOG", true);
                }
                // max value global
                if (node.LVMG !== undefined) {
                    appendTextBox(node, "LVMG", true);
                }

                // functions
                if (node.FunctionName !== undefined) {
                    var fn = node.FunctionName;
                    var handle = functionMap.get(fn);
                    if (handle != null && handle.settings !== undefined) {
                        handle.settings(fn, node);
                    }
                    if (node.Ref !== undefined) {
                        appendTextBox(node, "Ref", true);
                    }
                }

                if (node.Object !== undefined) {
                    var sublist = leveledLists[node.Object];
                    if (sublist !== undefined) {
                        gatherSettingsEntry(sublist);
                    }
                }

                if (node.Conditions !== undefined) {
                    for (var entry of node.Conditions) {
                        gatherSettingsEntry(entry);
                    }
                }

                if (node.Entries !== undefined) {
                    for (var entry of node.Entries) {
                        gatherSettingsEntry(entry);
                    }
                }
            }

            // key is and index path, value is a record { chance: 0.0, nochance: 0.0 }
            var chanceTree = {};
            var simulationTree = {};
            var uniqueIDGenerator = 0;

            function createChanceNode(id) {
                return {
                    uniqueID: uniqueIDGenerator++,
                    formID: id,
                    conditionMatch: true, // turns false if the level requirements or conditions are not met
                    conditionRandom: undefined, // if set, contains the number for random() :op: value live check
                    conditionCompare: undefined, // contains the operator code :op: for the comparison
                    conditionChance: 1,
                    levelMatch: true,
                    chanceNone: 0, // the node's default chance none value [0..1]
                    flags: 0, // the node's flags
                    max: 0, // the node's max value extracted
                    presentCount: 0,
                    hasSubLists: false,
                    items: []
                };
            }


            function calculateChances(rootFormID) {

                uniqueIDGenerator = 0;
                // build a tree and apply condition parameters
                
                chanceTree = createChanceNode(rootFormID);

                recurseForms(chanceTree);

                if (document.getElementById("simulate").checked) {
                    simulationTree = JSON.parse(JSON.stringify(chanceTree));

                    setTimeout(function() {
                        simulateTree();

                        chanceTree.emptyChance = recurseTree(chanceTree, undefined);

                        document.getElementById("simulate").disabled = false;
                        document.getElementById("rollagain").disabled = false;
                    }, 0);
                    return false;
                }

                // walk the tree
                chanceTree.emptyChance = recurseTree(chanceTree, undefined);

                document.getElementById("simulate").disabled = false;
                document.getElementById("rollagain").disabled = false;

                return true;
            }

            function isFlagsAll(flags) {
                return (flags & 4) != 0;
            }
            function isFlagsEach(flags) {
                return (flags & 2) != 0;
            }
            function isFlagsFirst(flags) {
                return (flags & 64) != 0;
            }

            // returns the chance for matching a random condition based on the associated operator
            function getConditionChance(node) {
                var val = node.conditionRandom;
                if (val !== undefined) {
                    var op = node.conditionCompare;
                    // RNG == X is always zero chance
                    if (op == 0) {
                        return 0;
                    }
                    // RNG != X is always 100% chance
                    if (op == 1) {
                        return 1;
                    }
                    if (op == 2 || op == 3) {
                        // RNG > X or RNG >= X 
                        return 1 - val;
                    }
                    if (op == 4 || op == 5) {
                        // RNG < X or RNG <= X
                        return val;
                    }
                }
                return 1;
            }

            function getSublistChance(node) {
                if (node.sublist !== undefined) {
                    return 1 - recurseTree(node.sublist, node);
                }
                return 1;
            }

            // returns the chance this node turns out to be empty
            function recurseTree(node, parent) {
                if (!node.conditionMatch) {
                    return 1;
                }

                var listChanceNone = node.chanceNone;
                var listConditionChance = node.conditionChance;

                var listSelfChance = (1 - listChanceNone) * listConditionChance;

                var entries = [];
                var hasConditionChance = false;
                var isRandom = (node.flags & 126) == 0;

                for (var entry of node.items) {
                    if (entry.levelMatch && (isRandom || entry.conditionMatch)) {
                        entries.push(entry);
                        hasConditionChance |= entry.conditionChance < 1;
                    }
                }

                if (entries.length == 0) {
                    return 1;
                }

                if (isFlagsFirst(node.flags)) {
                    if (hasConditionChance) {
                        return computeFirstWithConditionChance(entries, listSelfChance);
                    }
                    return computeFirst(entries, listSelfChance);
                }
                else if (isFlagsAll(node.flags)) {
                    if (node.max == 0) {
                        return computeAllUnlimited(entries, listSelfChance);
                    }
                    else if (node.max == 1) {
                        return computeAllUpToOne(entries, listSelfChance);
                    }
                    return computeAllMany(entries, node.max, listSelfChance);
                }
                var rolls = 1;
                if (!isRandom && parent !== undefined && parent.quantity > 1) {
                    rolls = parent.quantity;
                }
                if (hasConditionChance && !isRandom) {
                    return computeCombinatorialPick(entries, listSelfChance, rolls);
                }
                return computeUniformPick(entries, listSelfChance, rolls, !isRandom);
            }

            function computeCombinatorialPick(entries, listSelfChance, quantity) {
                if (entries.length > formulaLimit) {
                    return computeCombinatorialSimulation(entries, listSelfChance, quantity);
                }

                var n = entries.length;

                var bits = 1 << n;

                for (var i = 0; i < bits; i++) {
                    var product = 1;
                    var nonZeroCount = 0;
                    
                    for (var j = 0; j < n; j++) {
                        var mask = 1 << j;
                        var entry = entries[j];
                    
                        var cr = entry.conditionChance;
                        if ((i & mask) != 0) {
                            product *= cr;
                            nonZeroCount++;
                        } else {
                            product *= (1 - cr);
                        }
                    }

                    if (nonZeroCount != 0) {
                        product /= nonZeroCount;

                        for (var j = 0; j < n; j++) {
                            var mask = 1 << j;
                            var entry = entries[j];
                            if ((i & mask) != 0) {
                                entry.chance += product;
                            }
                        }
                    }
                }
                var sum = 0;
                for (var entry of entries) {
                    var selfChance = entry.chance * (1 - entry.chanceNone);
                    var sublistChance = getSublistChance(entry);

                    entry.apriori = listSelfChance * selfChance;
                    entry.chance = entry.apriori * sublistChance;

                    sum += selfChance * sublistChance;

                    if (quantity > 1) {
                        entry.chance = 1 - Math.pow(1 - entry.chance, quantity);
                    }

                }

                return Math.pow(1 - sum, quantity) * listSelfChance + (1 - listSelfChance);
            }

            function computeCombinatorialSimulation(entriesAll, listSelfChance, quantity) {
                var empty = 0;
                for (var r = 0; r < monteCarloCount * quantity; r++) {
                    var entries = [];
                        
                    for (var entry of entriesAll) {
                        if (entry.conditionChance == 1 || entry.conditionChance > Math.random()) {
                            entries.push(entry);
                        }
                    }

                    var n = entries.length;

                    if (n == 0) {
                        empty++;
                    } else {
                        var idx = Math.floor(n * Math.random());

                        var entry = entries[idx];
                        
                        if (entry.chanceNone == 0 || entry.chanceNone <= Math.random()) {
                            entry.apriori++;
                            var sublistChance = getSublistChance(entry);
                            if (sublistChance == 1 || sublistChance > Math.random()) {
                                entry.chance++;
                            } else {
                                empty++;
                            }
                        } else {
                            empty++;
                        }
                    }
                }

                for (var entry of entriesAll) {
                    entry.apriori = entry.apriori * listSelfChance / monteCarloCount;
                    entry.chance = entry.chance * listSelfChance / monteCarloCount;
                }
                return listSelfChance * empty / monteCarloCount + (1 - listSelfChance);
            }

            function computeUniformPick(entries, listSelfChance, quantity, isEach) {
                var uniformChance = listSelfChance / entries.length;
                var sum = 0;

                for (var entry of entries) {

                    entry.apriori = (1 - entry.chanceNone) * uniformChance;
                    if (!isEach) {
                        if (!entry.conditionMatch) {
                            entry.apriori = 0;
                        } else {
                            entry.aprioiry *= entry.conditionChance;
                        }
                    }

                    var sublistChance = getSublistChance(entry);

                    entry.chance = entry.apriori * sublistChance;

                    sum += entry.chance;

                    if (quantity > 1) {
                        entry.chance = 1 - Math.pow(1 - entry.chance, quantity);
                    }

                }

                if (quantity > 1) {
                    return Math.pow(1 - sum, quantity);
                }
                return 1 - sum;
            }

            function bitCount(n) {
                n = n - ((n >> 1) & 0x55555555);
                n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
                return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
            }

            function computeAllMany(entries, max, listSelfChance) {
                if (entries.length > formulaLimit) {
                    return computeManySimulation(entries, max, listSelfChance);
                }

                var empty = 1;

                for (var i = 0; i < max && i < entries.length; i++) {
                    var entry = entries[i];
                    entry.apriori = (1 - entry.chanceNone) * entry.conditionChance;

                    var sublistChance = getSublistChance(entry);

                    entry.chance = entry.apriori * sublistChance;
                    empty *= 1 - entry.chance * sublistChance;
                }

                var lowerBitsAllOne = (1 << max) - 1;
                var sum = 0;
                for (var i = max; i < entries.length; i++) {
                    var entry = entries[i];

                    var minPattern = (1 << (i - 1));
                    var maxPattern = (1 << i) - 1;
                    
                    for (var p = minPattern; p <= maxPattern; p++) {
                        if (bitCount(p) == max) {
                            var product = 1;
                            for (var b = 0; b < i; b++) {
                                var mask = 1 << b;
                                var e = entries[b];

                                var sublistChance = getSublistChance(e);
                                var chance = (1 - e.chanceNone) * e.conditionChance * sublistChance;
                                
                                if ((p & mask) != 0) {
                                    product *= chance;
                                } else {
                                    product *= 1 - chance;
                                }
                            }
                            sum += product;
                        }
                    }
                    var entry = entries[i];
                    var selfChance = (1 - entry.chanceNone) * entry.conditionChance;
                    entry.apriori = selfChance * (1 - sum);

                    var sublistChance = getSublistChance(entry);

                    entry.chance = entry.apriori * sublistChance;
                    empty *= 1 - selfChance * sublistChance;
                }

                for (var entry of entries) {
                    entry.apriori *= listSelfChance;
                    entry.chance *= listSelfChance;
                }

                return (1 - listSelfChance) + listSelfChance * empty;
            }


            function computeManySimulation(entries, max, listSelfChance) {
                var empty = 0;
                for (var r = 0; r < monteCarloCount; r++) {
                    var found = 0;
                    for (var entry of entries) {
                        if (entry.conditionChance == 1 || entry.conditionChance > Math.random()) {
                            if (entry.chanceNone == 0 || entry.chanceNone <= Math.random()) {
                                var sublistChance = getSublistChance(entry);

                                if (sublistChance == 1 || sublistChance > Math.random()) {
                                    entry.chance++;
                                    if (++found == max) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (found == 0) {
                        empty++;
                    }
                }

                for (var entry of entries) {
                    entry.chance = entry.chance * listSelfChance / monteCarloCount;
                }
                return listSelfChance * empty / monteCarloCount + (1 - listSelfChance);
            }

            function computeAllUpToOne(entries, listSelfChance) {
                var empty = 1;

                for (var entry of entries) {

                    var selfChance = (1 - entry.chanceNone) * entry.conditionChance;
                    var sublistChance = getSublistChance(entry);

                    entry.apriori = listSelfChance * selfChance * empty;

                    entry.chance = entry.apriori * sublistChance;

                    empty *= (1 - selfChance * sublistChance);
                }

                return (1 - listSelfChance) + listSelfChance * empty;
            }

            function computeAllUnlimited(entries, listSelfChance) {
                var empty = 1;

                for (var entry of entries) {

                    var selfChance = (1 - entry.chanceNone) * entry.conditionChance;
                    var sublistChance = getSublistChance(entry);

                    entry.apriori = listSelfChance * selfChance;

                    entry.chance = entry.apriori * sublistChance;

                    empty *= (1 - selfChance * sublistChance);
                }

                return empty;
            }

            function computeFirst(entries, listSelfChance) {
                var entry = entries[0];

                entry.apriori = listSelfChance * (1 - entry.chanceNone);

                var sublistChance = getSublistChance(entry);

                entry.chance = entry.apriori * sublistChance;

                return 1 - entry.chance;
            }

            function computeFirstWithConditionChance(entries, listSelfChance) {
                var sum = 0;
                var empty = 1;

                for (var entry of entries) {
                    var selfChance = (1 - entry.chanceNone) * entry.conditionChance;
                    entry.apriori = listSelfChance * selfChance * empty;

                    var sublistChance = getSublistChance(entry);

                    entry.chance = entry.apriori * sublistChance;

                    empty *= 1 - entry.conditionChance;

                    sum += entry.chance;
                }

                return 1 - sum;
            }

            function incrementChance(entry) {
                if (entry.chance === undefined) {
                    entry.chance = 1;
                } else {
                    entry.chance++;
                }
            }

            function simulateTree() {
                linkParents(simulationTree, undefined);

                var rounds = parseInt(document.getElementById("simulateRolls").value);

                var empty = 0;
                for (var i = 0; i < rounds; i++) {
                    var outcome = simulateNode(simulationTree, null);

                    if (outcome.length == 0) {
                        empty++;
                    } else {
                        var dedup = new Map();

                        for (var entry of outcome) {
                            if (dedup.get(entry.uniqueID) === undefined) {
                                dedup.set(entry.uniqueID, 1);
                                incrementChance(entry);
                            }
                        }
                    }
                }

                applyRollCount(simulationTree, rounds);
                simulationTree.emptyChance = empty / rounds;
            }

            function linkParents(node, parentEntry) {
                for (var entry of node.items) {
                    entry.parent = parentEntry;
                    if (entry.sublist !== undefined) {
                        linkParents(entry.sublist, entry);
                    }
                }
            }

            function applyRollCount(node, count) {
                for (var entry of node.items) {
                    if (entry.chance !== undefined) {
                        entry.chance /= count;
                    }
                    if (entry.sublist !== undefined) {
                        applyRollCount(entry.sublist, count);
                    }
                }
            }

            function simulateChanceRoll(node) {
                return simulateConditionRoll(node)
                    && simulateChanceNoneRoll(node);
            }

            function simulateChanceNoneRoll(node) {
                return node.chanceNone <= Math.random();
            }

            function simulateConditionRoll(node) {
                var val = node.conditionRandom;
                if (val !== undefined) {
                    var rng = Math.random();
                    var op = node.conditionCompare;
                    if (op == 0) {
                        return rng == val;
                    }
                    if (op == 1) {
                        return rng != val;
                    }
                    if (op == 2) {
                        return rng > val;
                    }
                    if (op == 3) {
                        return rng >= val;
                    }
                    if (op == 4) {
                        return rng < val;
                    }
                    if (op == 5) {
                        return rng <= val;
                    }
                    return false;
                }
                return true;
            }

            function simulateNode(node, parentEntry) {
                var result = [];
                if (node.conditionMatch) {
                    if (simulateChanceRoll(node)) {
                        if (isFlagsFirst(node.flags)) {
                            for (var entry of node.items) {
                                if (entry.levelMatch && entry.conditionMatch && simulateConditionRoll(entry)) {
                                    if (simulateChanceNoneRoll(entry)) {
                                        if (entry.sublist === undefined) {
                                            result.push(entry);
                                        } else {
                                            var subresult = simulateNode(entry.sublist, entry);
                                            if (subresult.length != 0) {
                                                for (var sub of subresult) {
                                                    result.push(sub);
                                                }
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        else if (isFlagsAll(node.flags)) {
                            var entriesFound = 0;
                            for (var entry of node.items) {
                                if (entry.levelMatch && entry.conditionMatch) {
                                    if (simulateChanceRoll(entry)) {
                                        if (entry.sublist === undefined) {
                                            result.push(entry);
                                            entriesFound++;
                                        } else {
                                            var subresult = simulateNode(entry.sublist, entry);
                                            if (subresult.length != 0) {
                                                for (var sub of subresult) {
                                                    result.push(sub);
                                                }
                                                entriesFound++;
                                            }
                                        }
                                        if (node.max > 0 && entriesFound >= node.max) {
                                            break;
                                        }
                                    }
                                }
                            }
                        } else {
                            var rerolls = 1;
                            var isEach = isFlagsEach(node.flags);

                            if (isEach && parentEntry != null && parentEntry.quantity > 1) {
                                rerolls = parentEntry.quantity;
                            }

                            for (var i = 0; i < rerolls; i++) {
                                var entriesToPickFrom = [];
                                for (var entry of node.items) {
                                    if (entry.levelMatch && (!isEach || (entry.conditionMatch && simulateConditionRoll(entry)))) {
                                        entriesToPickFrom.push(entry);
                                    }
                                }

                                if (entriesToPickFrom.length != 0) {
                                    var pickIndex = Math.floor(entriesToPickFrom.length * Math.random());
                                    var pick = entriesToPickFrom[pickIndex];
                                    if (simulateChanceNoneRoll(pick)) {
                                        if (isEach || (pick.conditionMatch && simulateConditionRoll(pick))) {
                                            if (pick.sublist === undefined) {
                                                result.push(pick);
                                            } else {
                                                var subresult = simulateNode(pick.sublist, pick);
                                                for (var subentry of subresult) {
                                                    result.push(subentry);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return result;
            }

            function getSettingsValue(key) {
                var input = settingsMap.get(key);
                if (input !== undefined) {
                    if (input.selectedIndex !== undefined) {
                        return input.options[input.selectedIndex].value;
                    }
                    else if (input.type !== undefined) {
                        if (input.type === "checkbox") {
                            return input.checked ? 1 : 0;
                        }
                        return parseFloat(input.value);
                    }
                    return 0;
                }
                return undefined;
            }

            function decodeValueOverride(node, defaultKey, globalKey, curveKey) {
                var globalFormID = node[globalKey];
                var curveFormID = node[curveKey];

                if (curveFormID !== undefined) {
                    var x = getSettingsValue(globalFormID);
                    if (x === undefined) {
                        x = globals[globalFormID];
                    }
                    return interpolate(curves[curveFormID], x);
                }
                else if (globalFormID !== undefined) {
                    var x = getSettingsValue(globalFormID);
                    if (x === undefined) {
                        x = globals[globalFormID];
                    }
                    return x;
                }
                var defaultValue = node[defaultKey];
                return defaultValue !== undefined ? defaultValue : 0;
            }

            function evaluateFunction(cond) {
                var compareWith = cond.Value;
                // compare with global instead?
                if (compareWith === undefined) {
                    compareWith = getSettingsValue(cond.Ref);
                }

                var fn = cond.FunctionName;

                var functionResult = "";
                var handle = functionMap.get(fn);
                if (handle != null && handle.evaluate !== undefined) {
                    functionResult = handle.evaluate(fn, cond);
                }

                var op = (cond.Operator & 0xFF) >> 5;
                
                var evaluation = false;

                if (typeof(functionResult) === "string") {
                    functionResult = parseFloat(functionResult.replace(',', '.'));
                }
                if (typeof(compareWith) === "string") {
                    compareWith = parseFloat(compareWith.replace(',', '.'));
                }

                if (op == 0) {
                    evaluation = functionResult == compareWith;
                }
                else if (op == 1) {
                    evaluation = functionResult != compareWith;
                }
                else if (op == 2) {
                    evaluation = functionResult > compareWith;
                }
                else if (op == 3) {
                    evaluation = functionResult >= compareWith;
                }
                else if (op == 4) {
                    evaluation = functionResult < compareWith;
                }
                else if (op == 5) {
                    evaluation = functionResult <= compareWith;
                }

                // when evaluating the condition for pruning, we consider RNG to always match
                if (fn == "GetRandomPercent") {
                    evaluation = true;
                }
                return evaluation;
            }

            function evaluateConditions(Conditions) {


                var orGroup = [];
                var andGroups = [ orGroup ];

                for (var cond of Conditions) {
                    orGroup.push(cond);
                    var logicAnd = (cond.Operator & 1) == 0;
                    if (logicAnd) {
                        orGroup = [];
                        andGroups.push(orGroup);
                    }
                }

                var andOutcome = true;

                for (var orGroup of andGroups) {
                    var orOutcome = orGroup.length == 0; 
                    for (var cond of orGroup) {
                        orOutcome |= evaluateFunction(cond);
                    }
                    andOutcome &= orOutcome;
                }

                return andOutcome;
            }

            function patchRandomPercent(node, target) {
                for (var cond of node.Conditions) {
                    if (cond.FunctionName == "GetRandomPercent") {
                        var val = "";
                        if (cond.Ref !== undefined) {
                            val = getSettingsValue(cond.Ref);
                        } else {
                            val = cond.Value;
                        }
                        var op = (cond.Operator & 0xFF) >> 5;
                        target.conditionRandom = val / 100.0;
                        target.conditionCompare = op;
                        target.conditionChance = getConditionChance(target);
                    }
                }
            }

            function recurseForms(node) {
                var lvli = leveledLists[node.formID];

                node.flags = lvli.LVLF;
                node.max = decodeValueOverride(lvli, "LVMV", "LVMG", "LVMT");
                node.chanceNone = decodeValueOverride(lvli, "LVCV", "LVLG", "LVCT") / 100.0;

                if (lvli.Conditions !== undefined) {
                    patchRandomPercent(lvli, node);
                    node.conditionMatch = evaluateConditions(lvli.Conditions);
                }

                var isClosestLevel = (lvli.LVLF & 5) == 0;

                if (lvli.Entries !== undefined) {
                    let settingsLevel = getSettingsValue("MinLevel");

                    var closestLevel = 0;

                    var entryIndex = 0;
                    for (var entry of lvli.Entries) {

                        var entryNode = {
                            uniqueID: uniqueIDGenerator++,
                            formID: entry.Object,
                            conditionMatch: true,
                            conditionRandom: undefined, // if set, contains the number for random() >= value live check
                            conditionCompare: undefined, // contains the operator code :op: for the comparison
                            conditionChance: 1,
                            levelMatch: true,
                            chanceNone: 0, // the node's default chance none value [0..1]
                            chance: 0, // default chance amount
                            apriori: 0, // the chance before the items sublist is considered
                            level: 0,
                            quantity: 1,
                            index: entryIndex,
                            sublist: undefined
                        };

                        node.items.push(entryNode);
                        entryNode.chanceNone = decodeValueOverride(entry, "LVOV", "LVOC", "LVOT") / 100.0;
                        entryNode.level = decodeValueOverride(entry, "LVLV", "LVOG", "ZZZZ");
                        entryNode.quantity = decodeValueOverride(entry, "LVIV", "LVIG", "ZZZZ");
                        
                        if (entry.Conditions !== undefined) {
                            // find unique conditions such as GetRandomPercent
                            patchRandomPercent(entry, entryNode)
                            entryNode.conditionMatch = evaluateConditions(entry.Conditions);
                        }

                        if (isClosestLevel && entryNode.conditionMatch && entryNode.level <= settingsLevel) {
                            closestLevel = Math.max(closestLevel, entryNode.level);
                        }

                        if (getGroupID(entry.Object) === "LVLI") {
                            node.hasSubLists = true;
                            entryNode.sublist = createChanceNode(entry.Object);
                            recurseForms(entryNode.sublist, entryNode);
                        }

                        entryIndex++;
                    }

                    for (var n of node.items) {
                        if (isClosestLevel) {
                            n.levelMatch = n.level == closestLevel;
                        } else {
                            n.levelMatch = n.level <= settingsLevel;
                        }
                        if (n.conditionMatch && n.levelMatch) {
                            node.presentCount++;
                        }
                    }
                }
            }

            function showChain(formIDs) {
                currentFormIDs = formIDs;

                gatherSettings(formIDs[0]);

                updateChances(formIDs);
            }

            function updateChances(formIDs) {

                var updateFn = function(sender) {
                    document.getElementById("simulate").disabled = true;
                    document.getElementById("rollagain").disabled = true;

                    updateChances(currentFormIDs);
                };

                document.getElementById("simulate").oninput = updateFn;
                document.getElementById("rollagain").onclick = updateFn;

                calculateChances(formIDs[0]);

                setTimeout(function() {
                    renderTable(formIDs);
                }, 0);
            }

            function renderTable(formIDs) {
                var mainTable = document.getElementById("listtable");

                clear(mainTable);

                generateTable(mainTable, formIDs, 0, chanceTree, 1);

                var tableLinks = document.getElementById("tablelinks");
                tableLinks.innerHTML = "";

                var patchSel = document.getElementById("versionselect");

                for (var i = 0; i < patchSel.options.length; i++) {
                    var ver = patchSel.options[i].value;

                    var lnk = prepareLinkDefault(ver);
                    lnk += "&formids=" + encodeURIComponent(formIDs.join("-"));
                    var tableLink = document.createElement("a");
                    tableLinks.appendChild(tableLink);
                    
                    tableLink.target = "_blank";
                    tableLink.href = lnk;
                    tableLink.innerText = ver + " link to this table";
                    tableLink.title = patchSel.options[i].text;

                    if (i != 0) {
                        tableLink.style.paddingLeft = "20px";
                    }
                }

                var coalesce = document.getElementById("Coalesce");
                let fids = formIDs;
                coalesce.oninput = function() {
                    renderTable(fids);
                };


                var showFail = document.getElementById("ShowFailedConditions");
                showFail.oninput = function() {
                    renderTable(fids);
                };

                generateItemTable();
            }

            function generateItemTable() {
                var itemTable = document.getElementById("itemtable");
                clear(itemTable);

                var row = itemTable.insertRow(itemTable.rows.length);
                row.style.backgroundColor = "#FFCC00";
                row.style.fontWeight = "bold";
                        
                var cll = row.insertCell(row.cells.length);
                cll.innerText = "Item";
                cll = row.insertCell(row.cells.length);
                cll.innerText = "Calc";
                cll.title = "Calculated chance";

                var leafs = [];

                recurseForItems(chanceTree, leafs, 1);

                var includeSim = document.getElementById("simulate").checked;

                if (includeSim) {
                    cll = row.insertCell(row.cells.length);
                    cll.innerText = "Sim";
                    cll.title = "Simulated chance";

                    var leafsSim = [];
                    recurseForSimItems(simulationTree, leafsSim);

                    var leafsMap = new Map();
                    for (var leaf of leafs) {
                        leafsMap.set(leaf.uniqueID, leaf);
                    }

                    for (var leaf of leafsSim) {
                        var existingLeaf = leafsMap.get(leaf.uniqueID);
                        if (existingLeaf != null) {
                            existingLeaf.chanceSim = leaf.chance;
                        } else {
                            leafs.push(leaf);
                            leaf.chanceSim = leaf.chance;
                            leaf.chance = undefined;
                            leafsMap.set(leaf.uniqueID, leaf);
                        }
                    }
                }

                if (document.getElementById("Coalesce").checked) {
                    for (var i = leafs.length - 1; i > 0; i--) {
                        var curr = leafs[i];
                        for (var j = i - 1; j >= 0; j--) {
                            var prev = leafs[j];
                            if (prev.formID == curr.formID && prev.quantity == curr.quantity) {

                                if (prev.chance === undefined) {
                                    prev.chance = curr.chance;
                                } 
                                else if (curr.chance !== undefined) {
                                    prev.chance += curr.chance;
                                }

                                if (prev.chanceSim === undefined) {
                                    prev.chanceSim = curr.chanceSim;
                                } 
                                else if (curr.chanceSim !== undefined) {
                                    prev.chanceSim += curr.chanceSim;
                                }

                                prev.coalesced = (prev.coalesced !== undefined ? prev.coalesced : 1)
                                    + (curr.coalesced !== undefined ? curr.coalesced : 1);

                                curr.skip = true;
                                break;
                            }
                        }
                    }
                }

                var resultRows = 0;
                for (var leaf of leafs) {
                    if (leaf.skip) {
                        continue;
                    }
                    row = itemTable.insertRow(itemTable.rows.length);
                    
                    cll = row.insertCell(row.cells.length);
                    cll.innerHTML = createNukaLink(leaf.formID);

                    var desc = getDescription(leaf.formID);
                    if (desc !== "") {
                        cll.innerHTML += "&nbsp;<b>\"" + desc + "\"</b>";
                    }

                    if (leaf.quantity > 1) {
                        cll.innerHTML += "&nbsp;<span style='color: blue; font-weight: bold; border: 1px dotted blue;'>&nbsp;x&nbsp;" + leaf.quantity + "&nbsp;</span>";
                    }
                    if (leaf.coalesced > 1) {
                        cll.innerHTML += "&nbsp;(<span style='border: 1px dotted green; font-weight: bold; color: green;'>&nbsp;"
                                 + leaf.coalesced + "&nbsp;</span> <span style='font-weight: bold' title='This entry appeared multiple times and has been coalesced into one row.'>&#x1F5DC;</span>)";
                    }

                    cll = row.insertCell(row.cells.length);
                    cll.style.border="1px dotted red";
                    cll.style.fontWeight = "bold";
                    cll.style.paddingLeft = "5px";
                    cll.style.paddingRight = "5px";
                    if (leaf.chance !== undefined) {
                        cll.style.color = "red";
                        cll.style.textAlign = "right";
                        cll.innerText = (leaf.chance * 100.0).toFixed(3) + "%";
                    } else {
                        cll.style.color = "black";
                        cll.style.textAlign = "center";
                        cll.innerText = "- missing -";
                    }

                    if (includeSim) {
                        if (leaf.chance === undefined || leaf.chanceSim === undefined) {
                            row.style.backgroundColor = "#FFECEC";
                        }

                        cll = row.insertCell(row.cells.length);
                        cll.style.border="1px dotted blue";
                        cll.style.fontWeight = "bold";
                        cll.style.paddingLeft = "5px";
                        cll.style.paddingRight = "5px";
                        if (leaf.chanceSim !== undefined) {
                            cll.style.color = "blue";
                            cll.style.textAlign = "right";
                            cll.innerText = (leaf.chanceSim * 100.0).toFixed(3) + "%";
                        } else {
                            cll.style.color = "black";
                            cll.style.textAlign = "center";
                            cll.innerText = "- missing -";
                        }
                    }
                    resultRows++;
                }

                row = itemTable.insertRow(itemTable.rows.length);
                    
                cll = row.insertCell(row.cells.length);
                cll.innerText = "Nothing dropped";
                cll.style.fontWeigt = "bold";
                cll.style.borderTop = "1px solid black";

                cll = row.insertCell(row.cells.length);
                cll.innerText = (chanceTree.emptyChance * 100.0).toFixed(3) + "%";
                cll.style.border = "1px dotted red";
                cll.style.fontWeight = "bold";
                cll.style.color = "red";
                cll.style.textAlign = "right";

                if (includeSim) {
                    cll = row.insertCell(row.cells.length);
                    cll.innerText = (simulationTree.emptyChance * 100.0).toFixed(3) + "%";
                    cll.style.border="1px dotted blue";
                    cll.style.fontWeight = "bold";
                    cll.style.color = "blue";
                    cll.style.textAlign = "right";
                }

                if (resultRows == 0) {
                    row = itemTable.insertRow(itemTable.rows.length);
                    cll = row.insertCell(row.cells.length);
                    cll.style.fontStyle = "italic";
                    cll.innerText = "No items can drop with this setup."
                    cll.colSpan = includeSim ? 3 : 2;
                }
            }

            function recurseForItems(node, leafs, parentChance) {
                if (node.conditionMatch) {
                    for (var entry of node.items) {
                        if (entry.levelMatch && entry.conditionMatch) {
                            var entrySelfChance = entry.chance;
                            if (entrySelfChance !== undefined) {
                                if (entry.sublist == undefined) {
                                    leafs.push({
                                        formID : entry.formID,
                                        uniqueID: entry.uniqueID,
                                        quantity: entry.quantity,
                                        chance: entrySelfChance * parentChance
                                    });
                                } else {
                                    var cascadeChance = entrySelfChance * parentChance;
                                    if (entry.apriori !== undefined) {
                                        cascadeChance = entry.apriori * parentChance;
                                    }
                                    recurseForItems(entry.sublist, leafs, cascadeChance);
                                }
                            }
                        }
                    }
                }
            }

            function recurseForSimItems(node, leafs) {
                if (node.conditionMatch) {
                    for (var entry of node.items) {
                        if (entry.levelMatch && entry.conditionMatch) {
                            if (entry.sublist == undefined) {
                                leafs.push({
                                    formID : entry.formID,
                                    uniqueID: entry.uniqueID,
                                    quantity: entry.quantity,
                                    chance: entry.chance
                                });
                            } else {
                                recurseForSimItems(entry.sublist, leafs);
                            }
                        }
                    }
                }
            }

            function clear(table) {
                for (var i = table.rows.length - 1; i >= 0; i--) {
                    table.deleteRow(i);
                }
            }

            function showList(formID) {
                showChain([formID]);
            }

            function createIgnoreRow(resultsTable, ignoreFlag) {
                var n = resultsTable.rows.length;
                var row = resultsTable.insertRow(n);
                var cll = row.insertCell(row.cells.length);
                cll.colSpan = 3;
                cll.style.borderTop = "1px solid black";
                cll.style.textAlign = "center";
                cll.style.fontStyle = "italic";
                var txt = [];
                if ((ignoreFlag & 1) != 0) {
                    txt.push("Atom Shop");
                }
                if ((ignoreFlag & 2) != 0) {
                    txt.push("Cut content");
                }
                if ((ignoreFlag & 4) != 0) {
                    txt.push("Debug content");
                }
                cll.innerText = "Entries found but ignored due to options: " + txt.join(", ");
            }

            function searchLists(entryPredicate) {
                var textField = document.getElementById("listsearchterm");
                var regexps = parseSearchText(textField.value);

                var resultsTable = document.getElementById("searchresults");

                clear(resultsTable);

                var includeATX = document.getElementById("IncludeATX").checked;
                var includeCut = document.getElementById("IncludeCut").checked;
                var includeDebug = document.getElementById("IncludeDebug").checked;

                var ignoreFlag = 0;

                var foundList = [];

                for (var formID in leveledLists) {
                    var editorId = getEditorID(formID).toLowerCase();
                    var match = false;

                    var nozeroFormID = formID.replace(/^0+/, "").toLowerCase();
                    while (nozeroFormID.charAt(0) == "0") {
                        nozeroFormID = nozeroFormID.substring(1);
                    }
                    
                    for (var regexp of regexps) {
                        if (regexp.test(nozeroFormID)) {
                            match = true;
                            break;
                        }
                        if (regexp.test(editorId)) {
                            match = true;
                            break;
                        }
                    }

                    if (match && entryPredicate !== undefined) {
                        match = entryPredicate(leveledLists[formID]);
                    }

                    if (match) {
                        if (!includeATX && editorId.startsWith("atx_")) {
                            ignoreFlag = ignoreFlag | 1;
                            continue;
                        }
                        if (!includeCut && (editorId.startsWith("zzz") || editorId.includes("cut"))) {
                            ignoreFlag = ignoreFlag | 2;
                            continue;
                        }
                        if (!includeDebug && (editorId.includes("debug") || editorId.includes("test"))) {
                            ignoreFlag = ignoreFlag | 4;
                            continue;
                        }

                        foundList.push(formID);
                    }
                }

                generateSearchResults(resultsTable, foundList, ignoreFlag);
            }

            function generateSearchResults(resultsTable, foundList, ignoreFlag) {

                if (document.getElementById("SortByEditorID").checked) {
                    foundList.sort((a, b) => {
                        var e1 = getEditorID(a);
                        var e2 = getEditorID(b);
                        return e1.localeCompare(e2);
                    });
                }

                for (var formID of foundList) {
                    var n = resultsTable.rows.length;
                    var row = resultsTable.insertRow(n);

                    if (n % 2 != 0) {
                        row.style.backgroundColor = "#E0E0E0";
                    }

                    /*
                    var cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerText = getGroupID(formID);
                    */
                    
                    cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerHTML = createListLink(formID, formID);

                    cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerHTML = createListLink(formID, getEditorID(formID));

                    cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerHTML = createListLink(formID, getDescription(formID));

                    cll = row.insertCell(row.cells.length);
                    cll.innerHTML = "<a href='https://nukacrypt.com/database/json/" + formID + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>"

                    cll = row.insertCell(row.cells.length);
                    cll.innerHTML = createOpenNewWindow(formID);
                }

                if (ignoreFlag != 0) {
                    createIgnoreRow(resultsTable, ignoreFlag);
                } else
                if (resultsTable.rows.length == 0) {
                    var n = resultsTable.rows.length;
                    var row = resultsTable.insertRow(n);
                    var cll = row.insertCell(row.cells.length);

                    cll.innerText = "No leveled lists found.";
                }
            }

            function searchItems() {
                var textField = document.getElementById("itemsearchterm");
                var regexps = parseSearchText(textField.value);

                var resultsTable = document.getElementById("searchresults");

                clear(resultsTable);

                var includeATX = document.getElementById("IncludeATX").checked;
                var includeCut = document.getElementById("IncludeCut").checked;
                var includeDebug = document.getElementById("IncludeDebug").checked;

                var ignoreFlag = 0;

                var foundList = [];

                for (var formID in leveledLists) {
                    var editorId = getEditorID(formID).toLowerCase();
                    var lvli = leveledLists[formID];

                    var match = false;

                    if (lvli.Entries === undefined) {
                        continue;
                    }

                    outer:
                    for (var listEntries of lvli.Entries) {
                        var entryId = listEntries.Object;
                        var nozeroEntryID = entryId.replace(/^0+/, "").toLowerCase();
                        var entryEditorId = getEditorID(entryId).toLowerCase();
                        var entryDescription = getDescription(entryId).toLowerCase();

                        for (var regexp of regexps) {
                            if (regexp.test(nozeroEntryID)) {
                                match = true;
                                break outer;
                            }
                            if (regexp.test(entryEditorId)) {
                                match = true;
                                break outer;
                            }
                            if (regexp.test(entryDescription)) {
                                match = true;
                                break outer;
                            }
                        }
                    }

                    if (match) {
                        if (!includeATX && editorId.startsWith("atx_")) {
                            ignoreFlag = ignoreFlag | 1;
                            continue;
                        }
                        if (!includeCut && (editorId.startsWith("zzz") || editorId.includes("cut"))) {
                            ignoreFlag = ignoreFlag | 2;
                            continue;
                        }
                        if (!includeDebug && (editorId.includes("debug") || editorId.includes("test"))) {
                            ignoreFlag = ignoreFlag | 4;
                            continue;
                        }

                        foundList.push(formID);
                    }
                }

                generateSearchResults(resultsTable, foundList, ignoreFlag);
            }

            document.getElementById("listsearchbtn").onclick = () => searchLists();
            document.getElementById("itemsearchbtn").onclick = searchItems;

            document.getElementById("listsearchterm").onkeydown = function(evt) {
                if (evt.keyCode == 13) {
                    searchLists();
                }
            };
            document.getElementById("itemsearchterm").onkeydown = function(evt) {
                if (evt.keyCode == 13) {
                    searchItems();
                }
            };

            document.getElementById("clearResults").onclick = function() {
                clear(document.getElementById("searchresults"));
            };

            var settingsToggle = document.getElementById("settingstoggle");
            settingsToggle.onclick = function() {
                var settingsTable = document.getElementById("settings");
                if (settingsTable.style.display !== "none") {
                    settingsTable.style.display = "none";
                    settingsToggle.innerHTML = "&nbsp;+&nbsp;"
                } else {
                    settingsTable.style.display = "table";
                    settingsToggle.innerHTML = "&nbsp;-&nbsp;"
                }
            };

            var q = location.search;

            if (q.includes("patch=")) {
                var idx = q.indexOf("patch=");
                var jdx = q.indexOf("&", idx + 1);
                if (jdx < 0) {
                    jdx = q.length;
                }
                var patch = q.substring(7, jdx);
                console.log(patch);
                var versionSelect = document.getElementById("versionselect");
                for (var i = 0; i < versionSelect.options.length; i++) {
                    var opt = versionSelect.options[i];
                    if (opt.value === patch) {
                        opt.selected = true;
                        break;
                    }
                }         
            }
            if (q.includes("noshowfail")) {
                document.getElementById("ShowFailedConditions").checked = false;
            }
            if (q.includes("nocoalesce")) {
                document.getElementById("Coalesce").checked = false;
            }

            document.getElementById("resetPage").onclick = function() {
                window.location = "chances.html";
            }

            var fs = document.getElementById("FindSpecial");
            fs.oninput = function() {
                document.getElementById("FindSpecialRow").style.display = fs.checked ? "table-row" : "none";
            };

            function doSpecialSearch(predicate) {
                var fb = document.getElementById("listsearchterm");
                if (fb.value == "") {
                    fb.value = "*";
                }
                searchLists(predicate);
            }

            function hasFunction(entry, name) {
                if (entry.Conditions !== undefined) {
                    for (var cond of entry.Conditions) {
                        if (cond.FunctionName === "GetRandomPercent") {
                            return true;
                        }
                    }
                }
            }

            document.getElementById("listsearchbtn").onclick = evt => doSpecialSearch();
            document.getElementById("SpecialAllMax0").onclick = evt => doSpecialSearch(entry => isFlagsAll(entry.LVLF) && (entry.LVMV === undefined || entry.LVMV === 1));
            document.getElementById("SpecialAllMax1").onclick = evt => doSpecialSearch(entry => isFlagsAll(entry.LVLF) && entry.LVMV === 1);
            document.getElementById("SpecialAllMax2").onclick = evt => doSpecialSearch(entry => isFlagsAll(entry.LVLF) && entry.LVMV > 1);
            document.getElementById("SpecialAllMaxGlobal").onclick = evt => doSpecialSearch(entry => isFlagsAll(entry.LVLF) && entry.LVMG !== undefined);
            document.getElementById("SpecialFirst").onclick = evt => doSpecialSearch(entry => isFlagsFirst(entry.LVLF));
            document.getElementById("SpecialFirstSub").onclick = evt => doSpecialSearch(entry => {
                if (isFlagsFirst(entry.LVLF)) {
                    if (entry.Entries !== undefined) {
                        for (var e of entry.Entries) {
                            var sub = leveledLists[e.Object];
                            if (sub) {
                                if (sub.Conditions !== undefined) {
                                    return true;
                                }
                                if (sub.Entries !== undefined) {
                                    for (var se of sub.Entries) {
                                        if (entry.Conditions !== undefined) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            });
            document.getElementById("SpecialForEach").onclick = evt => doSpecialSearch(entry => isFlagsEach(entry.LVLF));
            document.getElementById("SpecialPickRandom").onclick = evt => doSpecialSearch(entry => !isFlagsAll(entry.LVLF) && !isFlagsEach(entry.LVLF) && !isFlagsFirst(entry.LVLF));
            document.getElementById("SpecialListChanceNone").onclick = evt => doSpecialSearch(entry => entry.LVCV > 0 || entry.LVCG !== undefined);
            document.getElementById("SpecialGetRandomPercent").onclick = evt => doSpecialSearch(entry => {
                if (hasFunction(entry, "GetRandomPercent")) {
                    return true;
                }
                if (entry.Entries !== undefined) {
                    for (var e of entry.Entries) {
                        if (hasFunction(e, "GetRandomPercent")) {
                            return true;
                        }
                    }
                }
                return false;
            });

            document.getElementById("SpecialSelfTest").onclick = evt => { 
                var fb = document.getElementById("listsearchterm");
                fb.value = "A000*"
                document.getElementById("IncludeDebug").checked = true;
                doSpecialSearch();
            };

            document.getElementById("SpecialBugged1").onclick = evt => doSpecialSearch(entry => {
                if (isFlagsAll(entry.LVLF) && entry.Entries !== undefined) {
                    if (entry.Entries.length > 1) {
                        var first = entry.Entries[0];
                        if (leveledLists[first.Object] === undefined) {
                            if (first.LVOV === undefined && first.Conditions === undefined) {
                                if (first.LVOC === undefined) {
                                    if (entry.LVMV == 1) {
                                        return true;
                                    }
                                    if (entry.LVMG !== undefined) {
                                        if (globals[entry.LVMG] == 1) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            });
            document.getElementById("SpecialBugged2").onclick = evt => doSpecialSearch(entry => {
                if (entry.LVLF === undefined || entry.LVLF === 0 || entry.LVLF === 1) {
                    if (entry.Entries !== undefined) {
                        for (var e of entry.Entries) {
                            if (e.Conditions !== undefined) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });

            doLoad();
        </script>
    </body>
</html>